js-beautify
(v1.14.7)
Beautify JavaScript, JSON, React.js, HTML, CSS, SCSS, and SASS

Enable Dark Mode

Beautify JavaScript
Beautify Code (ctrl‑enter)

Copy to Clipboard
 
Select All
 
Clear
 No file chosen
Options

Indent with 4 spaces

Allow 5 newlines between tokens

Do not wrap lines

Braces with control statement
HTML <style>, <script> formatting:


Add one indent level
  End script and style with newline?
Support e4x/jsx syntax
Use comma-first list style?
Detect packers and obfuscators?
Preserve inline braces/code blocks?
Keep array indentation?
Break lines on chained methods?
Space before conditional: "if(x)" / "if (x)"
Unescape printable chars encoded as \xNN or \uNNNN?
Use JSLint-happy formatting tweaks?
Indent <head> and <body> sections?
Keep indentation on empty lines?
Use a simple textarea for code input?
Additional Settings (JSON):

{}
Your Selected Options (JSON):

{
  "indent_size": "4",
  "indent_char": " ",
  "max_preserve_newlines": "5",
  "preserve_newlines": true,
  "keep_array_indentation": false,
  "break_chained_methods": false,
  "indent_scripts": "normal",
  "brace_style": "collapse",
  "space_before_conditional": true,
  "unescape_strings": false,
  "jslint_happy": false,
  "end_with_newline": false,
  "wrap_line_length": "0",
  "indent_inner_html": false,
  "comma_first": false,
  "e4x": false,
  "indent_empty_lines": false
}
Created by Einar Lielmanis, maintained and evolved by Liam Newman.

All of the source code is completely free and open, available on GitHub under MIT licence, and we have a command-line version, python library and a node package as well.

We use the wonderful CodeMirror syntax highlighting editor, written by Marijn Haverbeke.

Made with a great help of many contributors. Special thanks to:
Jason Diamond, Patrick Hof, Nochum Sossonko, Andreas Schneider, Dave Vasilevsky, Vital Batmanov, Ron Baldwin, Gabriel Harrison, Chris J. Shull, Mathias Bynens, Vittorio Gambaletta, Stefano Sanfilippo and Daniel Stockman.

1
/*!
2
 * Bootstrap v5.3.0-alpha1 (https://getbootstrap.com/)
3
 * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
4
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
5
 */
6
! function(t, e) {
7
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = e()
8
}(this, (function() {
9
    "use strict";
10
    const t = "transitionend",
11
        e = t => (t && window.CSS && window.CSS.escape && (t = t.replace(/#([^\s"#']+)/g, ((t, e) => `#${CSS.escape(e)}`))), t),
12
        i = e => {
13
            e.dispatchEvent(new Event(t))
14
        },
15
        n = t => !(!t || "object" != typeof t) && (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
16
        s = t => n(t) ? t.jquery ? t[0] : t : "string" == typeof t && t.length > 0 ? document.querySelector(e(t)) : null,
17
        o = t => {
18
            if (!n(t) || 0 === t.getClientRects().length) return !1;
19
            const e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
20
                i = t.closest("details:not([open])");
21
            if (!i) return e;
22
            if (i !== t) {
23
                const e = t.closest("summary");
24
                if (e && e.parentNode !== i) return !1;
25
                if (null === e) return !1
26
            }
27
            return e
28
        },
29
        r = t => !t || t.nodeType !== Node.ELEMENT_NODE || !!t.classList.contains("disabled") || (void 0 !== t.disabled ? t.disabled : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
30
        a = t => {
31
            if (!document.documentElement.attachShadow) return null;
32
            if ("function" == typeof t.getRootNode) {
33
                const e = t.getRootNode();
34
                return e instanceof ShadowRoot ? e : null
35
            }
36
            return t instanceof ShadowRoot ? t : t.parentNode ? a(t.parentNode) : null
37
        },
38
        l = () => {},
39
        c = t => {
40
            t.offsetHeight
41
        },
42
        h = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null,
43
        d = [],
44
        u = () => "rtl" === document.documentElement.dir,
45
        f = t => {
46
            var e;
47
            e = () => {
48
                const e = h();
49
                if (e) {
50
                    const i = t.NAME,
51
                        n = e.fn[i];
52
                    e.fn[i] = t.jQueryInterface, e.fn[i].Constructor = t, e.fn[i].noConflict = () => (e.fn[i] = n, t.jQueryInterface)
53
                }
54
            }, "loading" === document.readyState ? (d.length || document.addEventListener("DOMContentLoaded", (() => {
55
                for (const t of d) t()
56
            })), d.push(e)) : e()
57
        },
58
        p = (t, e = [], i = t) => "function" == typeof t ? t(...e) : i,
59
        m = (e, n, s = !0) => {
60
            if (!s) return void p(e);
61
            const o = (t => {
62
                if (!t) return 0;
63
                let {
64
                    transitionDuration: e,
65
                    transitionDelay: i
66
                } = window.getComputedStyle(t);
67
                const n = Number.parseFloat(e),
68
                    s = Number.parseFloat(i);
69
                return n || s ? (e = e.split(",")[0], i = i.split(",")[0], 1e3 * (Number.parseFloat(e) + Number.parseFloat(i))) : 0
70
            })(n) + 5;
71
            let r = !1;
72
            const a = ({
73
                target: i
74
            }) => {
75
                i === n && (r = !0, n.removeEventListener(t, a), p(e))
76
            };
77
            n.addEventListener(t, a), setTimeout((() => {
78
                r || i(n)
79
            }), o)
80
        },
81
        g = (t, e, i, n) => {
82
            const s = t.length;
83
            let o = t.indexOf(e);
84
            return -1 === o ? !i && n ? t[s - 1] : t[0] : (o += i ? 1 : -1, n && (o = (o + s) % s), t[Math.max(0, Math.min(o, s - 1))])
85
        },
86
        _ = /[^.]*(?=\..*)\.|.*/,
87
        b = /\..*/,
88
        v = /::\d+$/,
89
        y = {};
90
    let w = 1;
91
    const A = {
92
            mouseenter: "mouseover",
93
            mouseleave: "mouseout"
94
        },
95
        E = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
96
​
97
    function T(t, e) {
98
        return e && `${e}::${w++}` || t.uidEvent || w++
99
    }
100
​
101
    function C(t) {
102
        const e = T(t);
103
        return t.uidEvent = e, y[e] = y[e] || {}, y[e]
104
    }
105
​
106
    function O(t, e, i = null) {
107
        return Object.values(t).find((t => t.callable === e && t.delegationSelector === i))
108
    }
109
​
110
    function x(t, e, i) {
111
        const n = "string" == typeof e,
112
            s = n ? i : e || i;
113
        let o = D(t);
114
        return E.has(o) || (o = t), [n, s, o]
115
    }
116
​
117
    function k(t, e, i, n, s) {
118
        if ("string" != typeof e || !t) return;
119
        let [o, r, a] = x(e, i, n);
120
        if (e in A) {
121
            const t = t => function(e) {
122
                if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return t.call(this, e)
123
            };
124
            r = t(r)
125
        }
126
        const l = C(t),
127
            c = l[a] || (l[a] = {}),
128
            h = O(c, r, o ? i : null);
129
        if (h) return void(h.oneOff = h.oneOff && s);
130
        const d = T(r, e.replace(_, "")),
131
            u = o ? function(t, e, i) {
132
                return function n(s) {
133
                    const o = t.querySelectorAll(e);
134
                    for (let {
135
                            target: r
136
                        } = s; r && r !== this; r = r.parentNode)
137
                        for (const a of o)
138
                            if (a === r) return N(s, {
139
                                delegateTarget: r
140
                            }), n.oneOff && I.off(t, s.type, e, i), i.apply(r, [s])
141
                }
142
            }(t, i, r) : function(t, e) {
143
                return function i(n) {
144
                    return N(n, {
145
                        delegateTarget: t
146
                    }), i.oneOff && I.off(t, n.type, e), e.apply(t, [n])
147
                }
148
            }(t, r);
149
        u.delegationSelector = o ? i : null, u.callable = r, u.oneOff = s, u.uidEvent = d, c[d] = u, t.addEventListener(a, u, o)
150
    }
151
​
152
    function L(t, e, i, n, s) {
153
        const o = O(e[i], n, s);
154
        o && (t.removeEventListener(i, o, Boolean(s)), delete e[i][o.uidEvent])
155
    }
156
​
157
    function S(t, e, i, n) {
158
        const s = e[i] || {};
159
        for (const [o, r] of Object.entries(s)) o.includes(n) && L(t, e, i, r.callable, r.delegationSelector)
160
    }
161
​
162
    function D(t) {
163
        return t = t.replace(b, ""), A[t] || t
164
    }
165
    const I = {
166
        on(t, e, i, n) {
167
            k(t, e, i, n, !1)
168
        },
169
        one(t, e, i, n) {
170
            k(t, e, i, n, !0)
171
        },
172
        off(t, e, i, n) {
173
            if ("string" != typeof e || !t) return;
174
            const [s, o, r] = x(e, i, n), a = r !== e, l = C(t), c = l[r] || {}, h = e.startsWith(".");
175
            if (void 0 === o) {
176
                if (h)
177
                    for (const i of Object.keys(l)) S(t, l, i, e.slice(1));
178
                for (const [i, n] of Object.entries(c)) {
179
                    const s = i.replace(v, "");
180
                    a && !e.includes(s) || L(t, l, r, n.callable, n.delegationSelector)
181
                }
182
            } else {
183
                if (!Object.keys(c).length) return;
184
                L(t, l, r, o, s ? i : null)
185
            }
186
        },
187
        trigger(t, e, i) {
188
            if ("string" != typeof e || !t) return null;
189
            const n = h();
190
            let s = null,
191
                o = !0,
192
                r = !0,
193
                a = !1;
194
            e !== D(e) && n && (s = n.Event(e, i), n(t).trigger(s), o = !s.isPropagationStopped(), r = !s.isImmediatePropagationStopped(), a = s.isDefaultPrevented());
195
            let l = new Event(e, {
196
                bubbles: o,
197
                cancelable: !0
198
            });
199
            return l = N(l, i), a && l.preventDefault(), r && t.dispatchEvent(l), l.defaultPrevented && s && s.preventDefault(), l
200
        }
201
    };
202
​
203
    function N(t, e = {}) {
204
        for (const [i, n] of Object.entries(e)) try {
205
            t[i] = n
206
        } catch (e) {
207
            Object.defineProperty(t, i, {
208
                configurable: !0,
209
                get: () => n
210
            })
211
        }
212
        return t
213
    }
214
    const P = new Map,
215
        j = {
216
            set(t, e, i) {
217
                P.has(t) || P.set(t, new Map);
218
                const n = P.get(t);
219
                n.has(e) || 0 === n.size ? n.set(e, i) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`)
220
            },
221
            get: (t, e) => P.has(t) && P.get(t).get(e) || null,
222
            remove(t, e) {
223
                if (!P.has(t)) return;
224
                const i = P.get(t);
225
                i.delete(e), 0 === i.size && P.delete(t)
226
            }
227
        };
228
​
229
    function M(t) {
230
        if ("true" === t) return !0;
231
        if ("false" === t) return !1;
232
        if (t === Number(t).toString()) return Number(t);
233
        if ("" === t || "null" === t) return null;
234
        if ("string" != typeof t) return t;
235
        try {
236
            return JSON.parse(decodeURIComponent(t))
237
        } catch (e) {
238
            return t
239
        }
240
    }
241
​
242
    function F(t) {
243
        return t.replace(/[A-Z]/g, (t => `-${t.toLowerCase()}`))
244
    }
245
    const H = {
246
        setDataAttribute(t, e, i) {
247
            t.setAttribute(`data-bs-${F(e)}`, i)
248
        },
249
        removeDataAttribute(t, e) {
250
            t.removeAttribute(`data-bs-${F(e)}`)
251
        },
252
        getDataAttributes(t) {
253
            if (!t) return {};
254
            const e = {},
255
                i = Object.keys(t.dataset).filter((t => t.startsWith("bs") && !t.startsWith("bsConfig")));
256
            for (const n of i) {
257
                let i = n.replace(/^bs/, "");
258
                i = i.charAt(0).toLowerCase() + i.slice(1, i.length), e[i] = M(t.dataset[n])
259
            }
260
            return e
261
        },
262
        getDataAttribute: (t, e) => M(t.getAttribute(`data-bs-${F(e)}`))
263
    };
264
    class $ {
265
        static get Default() {
266
            return {}
267
        }
268
        static get DefaultType() {
269
            return {}
270
        }
271
        static get NAME() {
272
            throw new Error('You have to implement the static method "NAME", for each component!')
273
        }
274
        _getConfig(t) {
275
            return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
276
        }
277
        _configAfterMerge(t) {
278
            return t
279
        }
280
        _mergeConfigObj(t, e) {
281
            const i = n(e) ? H.getDataAttribute(e, "config") : {};
282
            return {
283
                ...this.constructor.Default,
284
                ..."object" == typeof i ? i : {},
285
                ...n(e) ? H.getDataAttributes(e) : {},
286
                ..."object" == typeof t ? t : {}
287
            }
288
        }
289
        _typeCheckConfig(t, e = this.constructor.DefaultType) {
290
            for (const [s, o] of Object.entries(e)) {
291
                const e = t[s],
292
                    r = n(e) ? "element" : null == (i = e) ? `${i}` : Object.prototype.toString.call(i).match(/\s([a-z]+)/i)[1].toLowerCase();
293
                if (!new RegExp(o).test(r)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${r}" but expected type "${o}".`)
294
            }
295
            var i
296
        }
297
    }
298
    class W extends $ {
299
        constructor(t, e) {
300
            super(), (t = s(t)) && (this._element = t, this._config = this._getConfig(e), j.set(this._element, this.constructor.DATA_KEY, this))
301
        }
302
        dispose() {
303
            j.remove(this._element, this.constructor.DATA_KEY), I.off(this._element, this.constructor.EVENT_KEY);
304
            for (const t of Object.getOwnPropertyNames(this)) this[t] = null
305
        }
306
        _queueCallback(t, e, i = !0) {
307
            m(t, e, i)
308
        }
309
        _getConfig(t) {
310
            return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
311
        }
312
        static getInstance(t) {
313
            return j.get(s(t), this.DATA_KEY)
314
        }
315
        static getOrCreateInstance(t, e = {}) {
316
            return this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
317
        }
318
        static get VERSION() {
319
            return "5.3.0-alpha1"
320
        }
321
        static get DATA_KEY() {
322
            return `bs.${this.NAME}`
323
        }
324
        static get EVENT_KEY() {
325
            return `.${this.DATA_KEY}`
326
        }
327
        static eventName(t) {
328
            return `${t}${this.EVENT_KEY}`
329
        }
330
    }
331
    const B = t => {
332
            let i = t.getAttribute("data-bs-target");
333
            if (!i || "#" === i) {
334
                let e = t.getAttribute("href");
335
                if (!e || !e.includes("#") && !e.startsWith(".")) return null;
336
                e.includes("#") && !e.startsWith("#") && (e = `#${e.split("#")[1]}`), i = e && "#" !== e ? e.trim() : null
337
            }
338
            return e(i)
339
        },
340
        z = {
341
            find: (t, e = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e, t)),
342
            findOne: (t, e = document.documentElement) => Element.prototype.querySelector.call(e, t),
343
            children: (t, e) => [].concat(...t.children).filter((t => t.matches(e))),
344
            parents(t, e) {
345
                const i = [];
346
                let n = t.parentNode.closest(e);
347
                for (; n;) i.push(n), n = n.parentNode.closest(e);
348
                return i
349
            },
350
            prev(t, e) {
351
                let i = t.previousElementSibling;
352
                for (; i;) {
353
                    if (i.matches(e)) return [i];
354
                    i = i.previousElementSibling
355
                }
356
                return []
357
            },
358
            next(t, e) {
359
                let i = t.nextElementSibling;
360
                for (; i;) {
361
                    if (i.matches(e)) return [i];
362
                    i = i.nextElementSibling
363
                }
364
                return []
365
            },
366
            focusableChildren(t) {
367
                const e = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t => `${t}:not([tabindex^="-"])`)).join(",");
368
                return this.find(e, t).filter((t => !r(t) && o(t)))
369
            },
370
            getSelectorFromElement(t) {
371
                const e = B(t);
372
                return e && z.findOne(e) ? e : null
373
            },
374
            getElementFromSelector(t) {
375
                const e = B(t);
376
                return e ? z.findOne(e) : null
377
            },
378
            getMultipleElementsFromSelector(t) {
379
                const e = B(t);
380
                return e ? z.find(e) : []
381
            }
382
        },
383
        R = (t, e = "hide") => {
384
            const i = `click.dismiss${t.EVENT_KEY}`,
385
                n = t.NAME;
386
            I.on(document, i, `[data-bs-dismiss="${n}"]`, (function(i) {
387
                if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), r(this)) return;
388
                const s = z.getElementFromSelector(this) || this.closest(`.${n}`);
389
                t.getOrCreateInstance(s)[e]()
390
            }))
391
        };
392
    class q extends W {
393
        static get NAME() {
394
            return "alert"
395
        }
396
        close() {
397
            if (I.trigger(this._element, "close.bs.alert").defaultPrevented) return;
398
            this._element.classList.remove("show");
399
            const t = this._element.classList.contains("fade");
400
            this._queueCallback((() => this._destroyElement()), this._element, t)
401
        }
402
        _destroyElement() {
403
            this._element.remove(), I.trigger(this._element, "closed.bs.alert"), this.dispose()
404
        }
405
        static jQueryInterface(t) {
406
            return this.each((function() {
407
                const e = q.getOrCreateInstance(this);
408
                if ("string" == typeof t) {
409
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
410
                    e[t](this)
411
                }
412
            }))
413
        }
414
    }
415
    R(q, "close"), f(q);
416
    const V = '[data-bs-toggle="button"]';
417
    class K extends W {
418
        static get NAME() {
419
            return "button"
420
        }
421
        toggle() {
422
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"))
423
        }
424
        static jQueryInterface(t) {
425
            return this.each((function() {
426
                const e = K.getOrCreateInstance(this);
427
                "toggle" === t && e[t]()
428
            }))
429
        }
430
    }
431
    I.on(document, "click.bs.button.data-api", V, (t => {
432
        t.preventDefault();
433
        const e = t.target.closest(V);
434
        K.getOrCreateInstance(e).toggle()
435
    })), f(K);
436
    const Q = {
437
            endCallback: null,
438
            leftCallback: null,
439
            rightCallback: null
440
        },
441
        X = {
442
            endCallback: "(function|null)",
443
            leftCallback: "(function|null)",
444
            rightCallback: "(function|null)"
445
        };
446
    class Y extends $ {
447
        constructor(t, e) {
448
            super(), this._element = t, t && Y.isSupported() && (this._config = this._getConfig(e), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents())
449
        }
450
        static get Default() {
451
            return Q
452
        }
453
        static get DefaultType() {
454
            return X
455
        }
456
        static get NAME() {
457
            return "swipe"
458
        }
459
        dispose() {
460
            I.off(this._element, ".bs.swipe")
461
        }
462
        _start(t) {
463
            this._supportPointerEvents ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX) : this._deltaX = t.touches[0].clientX
464
        }
465
        _end(t) {
466
            this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), p(this._config.endCallback)
467
        }
468
        _move(t) {
469
            this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
470
        }
471
        _handleSwipe() {
472
            const t = Math.abs(this._deltaX);
473
            if (t <= 40) return;
474
            const e = t / this._deltaX;
475
            this._deltaX = 0, e && p(e > 0 ? this._config.rightCallback : this._config.leftCallback)
476
        }
477
        _initEvents() {
478
            this._supportPointerEvents ? (I.on(this._element, "pointerdown.bs.swipe", (t => this._start(t))), I.on(this._element, "pointerup.bs.swipe", (t => this._end(t))), this._element.classList.add("pointer-event")) : (I.on(this._element, "touchstart.bs.swipe", (t => this._start(t))), I.on(this._element, "touchmove.bs.swipe", (t => this._move(t))), I.on(this._element, "touchend.bs.swipe", (t => this._end(t))))
479
        }
480
        _eventIsPointerPenTouch(t) {
481
            return this._supportPointerEvents && ("pen" === t.pointerType || "touch" === t.pointerType)
482
        }
483
        static isSupported() {
484
            return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
485
        }
486
    }
487
    const U = "next",
488
        G = "prev",
489
        J = "left",
490
        Z = "right",
491
        tt = "slid.bs.carousel",
492
        et = "carousel",
493
        it = "active",
494
        nt = {
495
            ArrowLeft: Z,
496
            ArrowRight: J
497
        },
498
        st = {
499
            interval: 5e3,
500
            keyboard: !0,
501
            pause: "hover",
502
            ride: !1,
503
            touch: !0,
504
            wrap: !0
505
        },
506
        ot = {
507
            interval: "(number|boolean)",
508
            keyboard: "boolean",
509
            pause: "(string|boolean)",
510
            ride: "(boolean|string)",
511
            touch: "boolean",
512
            wrap: "boolean"
513
        };
514
    class rt extends W {
515
        constructor(t, e) {
516
            super(t, e), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === et && this.cycle()
517
        }
518
        static get Default() {
519
            return st
520
        }
521
        static get DefaultType() {
522
            return ot
523
        }
524
        static get NAME() {
525
            return "carousel"
526
        }
527
        next() {
528
            this._slide(U)
529
        }
530
        nextWhenVisible() {
531
            !document.hidden && o(this._element) && this.next()
532
        }
533
        prev() {
534
            this._slide(G)
535
        }
536
        pause() {
537
            this._isSliding && i(this._element), this._clearInterval()
538
        }
539
        cycle() {
540
            this._clearInterval(), this._updateInterval(), this._interval = setInterval((() => this.nextWhenVisible()), this._config.interval)
541
        }
542
        _maybeEnableCycle() {
543
            this._config.ride && (this._isSliding ? I.one(this._element, tt, (() => this.cycle())) : this.cycle())
544
        }
545
        to(t) {
546
            const e = this._getItems();
547
            if (t > e.length - 1 || t < 0) return;
548
            if (this._isSliding) return void I.one(this._element, tt, (() => this.to(t)));
549
            const i = this._getItemIndex(this._getActive());
550
            if (i === t) return;
551
            const n = t > i ? U : G;
552
            this._slide(n, e[t])
553
        }
554
        dispose() {
555
            this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
556
        }
557
        _configAfterMerge(t) {
558
            return t.defaultInterval = t.interval, t
559
        }
560
        _addEventListeners() {
561
            this._config.keyboard && I.on(this._element, "keydown.bs.carousel", (t => this._keydown(t))), "hover" === this._config.pause && (I.on(this._element, "mouseenter.bs.carousel", (() => this.pause())), I.on(this._element, "mouseleave.bs.carousel", (() => this._maybeEnableCycle()))), this._config.touch && Y.isSupported() && this._addTouchEventListeners()
562
        }
563
        _addTouchEventListeners() {
564
            for (const t of z.find(".carousel-item img", this._element)) I.on(t, "dragstart.bs.carousel", (t => t.preventDefault()));
565
            const t = {
566
                leftCallback: () => this._slide(this._directionToOrder(J)),
567
                rightCallback: () => this._slide(this._directionToOrder(Z)),
568
                endCallback: () => {
569
                    "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout((() => this._maybeEnableCycle()), 500 + this._config.interval))
570
                }
571
            };
572
            this._swipeHelper = new Y(this._element, t)
573
        }
574
        _keydown(t) {
575
            if (/input|textarea/i.test(t.target.tagName)) return;
576
            const e = nt[t.key];
577
            e && (t.preventDefault(), this._slide(this._directionToOrder(e)))
578
        }
579
        _getItemIndex(t) {
580
            return this._getItems().indexOf(t)
581
        }
582
        _setActiveIndicatorElement(t) {
583
            if (!this._indicatorsElement) return;
584
            const e = z.findOne(".active", this._indicatorsElement);
585
            e.classList.remove(it), e.removeAttribute("aria-current");
586
            const i = z.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
587
            i && (i.classList.add(it), i.setAttribute("aria-current", "true"))
588
        }
589
        _updateInterval() {
590
            const t = this._activeElement || this._getActive();
591
            if (!t) return;
592
            const e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
593
            this._config.interval = e || this._config.defaultInterval
594
        }
595
        _slide(t, e = null) {
596
            if (this._isSliding) return;
597
            const i = this._getActive(),
598
                n = t === U,
599
                s = e || g(this._getItems(), i, n, this._config.wrap);
600
            if (s === i) return;
601
            const o = this._getItemIndex(s),
602
                r = e => I.trigger(this._element, e, {
603
                    relatedTarget: s,
604
                    direction: this._orderToDirection(t),
605
                    from: this._getItemIndex(i),
606
                    to: o
607
                });
608
            if (r("slide.bs.carousel").defaultPrevented) return;
609
            if (!i || !s) return;
610
            const a = Boolean(this._interval);
611
            this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = s;
612
            const l = n ? "carousel-item-start" : "carousel-item-end",
613
                h = n ? "carousel-item-next" : "carousel-item-prev";
614
            s.classList.add(h), c(s), i.classList.add(l), s.classList.add(l), this._queueCallback((() => {
615
                s.classList.remove(l, h), s.classList.add(it), i.classList.remove(it, h, l), this._isSliding = !1, r(tt)
616
            }), i, this._isAnimated()), a && this.cycle()
617
        }
618
        _isAnimated() {
619
            return this._element.classList.contains("slide")
620
        }
621
        _getActive() {
622
            return z.findOne(".active.carousel-item", this._element)
623
        }
624
        _getItems() {
625
            return z.find(".carousel-item", this._element)
626
        }
627
        _clearInterval() {
628
            this._interval && (clearInterval(this._interval), this._interval = null)
629
        }
630
        _directionToOrder(t) {
631
            return u() ? t === J ? G : U : t === J ? U : G
632
        }
633
        _orderToDirection(t) {
634
            return u() ? t === G ? J : Z : t === G ? Z : J
635
        }
636
        static jQueryInterface(t) {
637
            return this.each((function() {
638
                const e = rt.getOrCreateInstance(this, t);
639
                if ("number" != typeof t) {
640
                    if ("string" == typeof t) {
641
                        if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
642
                        e[t]()
643
                    }
644
                } else e.to(t)
645
            }))
646
        }
647
    }
648
    I.on(document, "click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", (function(t) {
649
        const e = z.getElementFromSelector(this);
650
        if (!e || !e.classList.contains(et)) return;
651
        t.preventDefault();
652
        const i = rt.getOrCreateInstance(e),
653
            n = this.getAttribute("data-bs-slide-to");
654
        return n ? (i.to(n), void i._maybeEnableCycle()) : "next" === H.getDataAttribute(this, "slide") ? (i.next(), void i._maybeEnableCycle()) : (i.prev(), void i._maybeEnableCycle())
655
    })), I.on(window, "load.bs.carousel.data-api", (() => {
656
        const t = z.find('[data-bs-ride="carousel"]');
657
        for (const e of t) rt.getOrCreateInstance(e)
658
    })), f(rt);
659
    const at = "show",
660
        lt = "collapse",
661
        ct = "collapsing",
662
        ht = '[data-bs-toggle="collapse"]',
663
        dt = {
664
            parent: null,
665
            toggle: !0
666
        },
667
        ut = {
668
            parent: "(null|element)",
669
            toggle: "boolean"
670
        };
671
    class ft extends W {
672
        constructor(t, e) {
673
            super(t, e), this._isTransitioning = !1, this._triggerArray = [];
674
            const i = z.find(ht);
675
            for (const t of i) {
676
                const e = z.getSelectorFromElement(t),
677
                    i = z.find(e).filter((t => t === this._element));
678
                null !== e && i.length && this._triggerArray.push(t)
679
            }
680
            this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
681
        }
682
        static get Default() {
683
            return dt
684
        }
685
        static get DefaultType() {
686
            return ut
687
        }
688
        static get NAME() {
689
            return "collapse"
690
        }
691
        toggle() {
692
            this._isShown() ? this.hide() : this.show()
693
        }
694
        show() {
695
            if (this._isTransitioning || this._isShown()) return;
696
            let t = [];
697
            if (this._config.parent && (t = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t => t !== this._element)).map((t => ft.getOrCreateInstance(t, {
698
                    toggle: !1
699
                })))), t.length && t[0]._isTransitioning) return;
700
            if (I.trigger(this._element, "show.bs.collapse").defaultPrevented) return;
701
            for (const e of t) e.hide();
702
            const e = this._getDimension();
703
            this._element.classList.remove(lt), this._element.classList.add(ct), this._element.style[e] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
704
            const i = `scroll${e[0].toUpperCase()+e.slice(1)}`;
705
            this._queueCallback((() => {
706
                this._isTransitioning = !1, this._element.classList.remove(ct), this._element.classList.add(lt, at), this._element.style[e] = "", I.trigger(this._element, "shown.bs.collapse")
707
            }), this._element, !0), this._element.style[e] = `${this._element[i]}px`
708
        }
709
        hide() {
710
            if (this._isTransitioning || !this._isShown()) return;
711
            if (I.trigger(this._element, "hide.bs.collapse").defaultPrevented) return;
712
            const t = this._getDimension();
713
            this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, c(this._element), this._element.classList.add(ct), this._element.classList.remove(lt, at);
714
            for (const t of this._triggerArray) {
715
                const e = z.getElementFromSelector(t);
716
                e && !this._isShown(e) && this._addAriaAndCollapsedClass([t], !1)
717
            }
718
            this._isTransitioning = !0, this._element.style[t] = "", this._queueCallback((() => {
719
                this._isTransitioning = !1, this._element.classList.remove(ct), this._element.classList.add(lt), I.trigger(this._element, "hidden.bs.collapse")
720
            }), this._element, !0)
721
        }
722
        _isShown(t = this._element) {
723
            return t.classList.contains(at)
724
        }
725
        _configAfterMerge(t) {
726
            return t.toggle = Boolean(t.toggle), t.parent = s(t.parent), t
727
        }
728
        _getDimension() {
729
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height"
730
        }
731
        _initializeChildren() {
732
            if (!this._config.parent) return;
733
            const t = this._getFirstLevelChildren(ht);
734
            for (const e of t) {
735
                const t = z.getElementFromSelector(e);
736
                t && this._addAriaAndCollapsedClass([e], this._isShown(t))
737
            }
738
        }
739
        _getFirstLevelChildren(t) {
740
            const e = z.find(":scope .collapse .collapse", this._config.parent);
741
            return z.find(t, this._config.parent).filter((t => !e.includes(t)))
742
        }
743
        _addAriaAndCollapsedClass(t, e) {
744
            if (t.length)
745
                for (const i of t) i.classList.toggle("collapsed", !e), i.setAttribute("aria-expanded", e)
746
        }
747
        static jQueryInterface(t) {
748
            const e = {};
749
            return "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1), this.each((function() {
750
                const i = ft.getOrCreateInstance(this, e);
751
                if ("string" == typeof t) {
752
                    if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
753
                    i[t]()
754
                }
755
            }))
756
        }
757
    }
758
    I.on(document, "click.bs.collapse.data-api", ht, (function(t) {
759
        ("A" === t.target.tagName || t.delegateTarget && "A" === t.delegateTarget.tagName) && t.preventDefault();
760
        for (const t of z.getMultipleElementsFromSelector(this)) ft.getOrCreateInstance(t, {
761
            toggle: !1
762
        }).toggle()
763
    })), f(ft);
764
    var pt = "top",
765
        mt = "bottom",
766
        gt = "right",
767
        _t = "left",
768
        bt = "auto",
769
        vt = [pt, mt, gt, _t],
770
        yt = "start",
771
        wt = "end",
772
        At = "clippingParents",
773
        Et = "viewport",
774
        Tt = "popper",
775
        Ct = "reference",
776
        Ot = vt.reduce((function(t, e) {
777
            return t.concat([e + "-" + yt, e + "-" + wt])
778
        }), []),
779
        xt = [].concat(vt, [bt]).reduce((function(t, e) {
780
            return t.concat([e, e + "-" + yt, e + "-" + wt])
781
        }), []),
782
        kt = "beforeRead",
783
        Lt = "read",
784
        St = "afterRead",
785
        Dt = "beforeMain",
786
        It = "main",
787
        Nt = "afterMain",
788
        Pt = "beforeWrite",
789
        jt = "write",
790
        Mt = "afterWrite",
791
        Ft = [kt, Lt, St, Dt, It, Nt, Pt, jt, Mt];
792
​
793
    function Ht(t) {
794
        return t ? (t.nodeName || "").toLowerCase() : null
795
    }
796
​
797
    function $t(t) {
798
        if (null == t) return window;
799
        if ("[object Window]" !== t.toString()) {
800
            var e = t.ownerDocument;
801
            return e && e.defaultView || window
802
        }
803
        return t
804
    }
805
​
806
    function Wt(t) {
807
        return t instanceof $t(t).Element || t instanceof Element
808
    }
809
​
810
    function Bt(t) {
811
        return t instanceof $t(t).HTMLElement || t instanceof HTMLElement
812
    }
813
​
814
    function zt(t) {
815
        return "undefined" != typeof ShadowRoot && (t instanceof $t(t).ShadowRoot || t instanceof ShadowRoot)
816
    }
817
    const Rt = {
818
        name: "applyStyles",
819
        enabled: !0,
820
        phase: "write",
821
        fn: function(t) {
822
            var e = t.state;
823
            Object.keys(e.elements).forEach((function(t) {
824
                var i = e.styles[t] || {},
825
                    n = e.attributes[t] || {},
826
                    s = e.elements[t];
827
                Bt(s) && Ht(s) && (Object.assign(s.style, i), Object.keys(n).forEach((function(t) {
828
                    var e = n[t];
829
                    !1 === e ? s.removeAttribute(t) : s.setAttribute(t, !0 === e ? "" : e)
830
                })))
831
            }))
832
        },
833
        effect: function(t) {
834
            var e = t.state,
835
                i = {
836
                    popper: {
837
                        position: e.options.strategy,
838
                        left: "0",
839
                        top: "0",
840
                        margin: "0"
841
                    },
842
                    arrow: {
843
                        position: "absolute"
844
                    },
845
                    reference: {}
846
                };
847
            return Object.assign(e.elements.popper.style, i.popper), e.styles = i, e.elements.arrow && Object.assign(e.elements.arrow.style, i.arrow),
848
                function() {
849
                    Object.keys(e.elements).forEach((function(t) {
850
                        var n = e.elements[t],
851
                            s = e.attributes[t] || {},
852
                            o = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : i[t]).reduce((function(t, e) {
853
                                return t[e] = "", t
854
                            }), {});
855
                        Bt(n) && Ht(n) && (Object.assign(n.style, o), Object.keys(s).forEach((function(t) {
856
                            n.removeAttribute(t)
857
                        })))
858
                    }))
859
                }
860
        },
861
        requires: ["computeStyles"]
862
    };
863
​
864
    function qt(t) {
865
        return t.split("-")[0]
866
    }
867
    var Vt = Math.max,
868
        Kt = Math.min,
869
        Qt = Math.round;
870
​
871
    function Xt() {
872
        var t = navigator.userAgentData;
873
        return null != t && t.brands ? t.brands.map((function(t) {
874
            return t.brand + "/" + t.version
875
        })).join(" ") : navigator.userAgent
876
    }
877
​
878
    function Yt() {
879
        return !/^((?!chrome|android).)*safari/i.test(Xt())
880
    }
881
​
882
    function Ut(t, e, i) {
883
        void 0 === e && (e = !1), void 0 === i && (i = !1);
884
        var n = t.getBoundingClientRect(),
885
            s = 1,
886
            o = 1;
887
        e && Bt(t) && (s = t.offsetWidth > 0 && Qt(n.width) / t.offsetWidth || 1, o = t.offsetHeight > 0 && Qt(n.height) / t.offsetHeight || 1);
888
        var r = (Wt(t) ? $t(t) : window).visualViewport,
889
            a = !Yt() && i,
890
            l = (n.left + (a && r ? r.offsetLeft : 0)) / s,
891
            c = (n.top + (a && r ? r.offsetTop : 0)) / o,
892
            h = n.width / s,
893
            d = n.height / o;
894
        return {
895
            width: h,
896
            height: d,
897
            top: c,
898
            right: l + h,
899
            bottom: c + d,
900
            left: l,
901
            x: l,
902
            y: c
903
        }
904
    }
905
​
906
    function Gt(t) {
907
        var e = Ut(t),
908
            i = t.offsetWidth,
909
            n = t.offsetHeight;
910
        return Math.abs(e.width - i) <= 1 && (i = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
911
            x: t.offsetLeft,
912
            y: t.offsetTop,
913
            width: i,
914
            height: n
915
        }
916
    }
917
​
918
    function Jt(t, e) {
919
        var i = e.getRootNode && e.getRootNode();
920
        if (t.contains(e)) return !0;
921
        if (i && zt(i)) {
922
            var n = e;
923
            do {
924
                if (n && t.isSameNode(n)) return !0;
925
                n = n.parentNode || n.host
926
            } while (n)
927
        }
928
        return !1
929
    }
930
​
931
    function Zt(t) {
932
        return $t(t).getComputedStyle(t)
933
    }
934
​
935
    function te(t) {
936
        return ["table", "td", "th"].indexOf(Ht(t)) >= 0
937
    }
938
​
939
    function ee(t) {
940
        return ((Wt(t) ? t.ownerDocument : t.document) || window.document).documentElement
941
    }
942
​
943
    function ie(t) {
944
        return "html" === Ht(t) ? t : t.assignedSlot || t.parentNode || (zt(t) ? t.host : null) || ee(t)
945
    }
946
​
947
    function ne(t) {
948
        return Bt(t) && "fixed" !== Zt(t).position ? t.offsetParent : null
949
    }
950
​
951
    function se(t) {
952
        for (var e = $t(t), i = ne(t); i && te(i) && "static" === Zt(i).position;) i = ne(i);
953
        return i && ("html" === Ht(i) || "body" === Ht(i) && "static" === Zt(i).position) ? e : i || function(t) {
954
            var e = /firefox/i.test(Xt());
955
            if (/Trident/i.test(Xt()) && Bt(t) && "fixed" === Zt(t).position) return null;
956
            var i = ie(t);
957
            for (zt(i) && (i = i.host); Bt(i) && ["html", "body"].indexOf(Ht(i)) < 0;) {
958
                var n = Zt(i);
959
                if ("none" !== n.transform || "none" !== n.perspective || "paint" === n.contain || -1 !== ["transform", "perspective"].indexOf(n.willChange) || e && "filter" === n.willChange || e && n.filter && "none" !== n.filter) return i;
960
                i = i.parentNode
961
            }
962
            return null
963
        }(t) || e
964
    }
965
​
966
    function oe(t) {
967
        return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
968
    }
969
​
970
    function re(t, e, i) {
971
        return Vt(t, Kt(e, i))
972
    }
973
​
974
    function ae(t) {
975
        return Object.assign({}, {
976
            top: 0,
977
            right: 0,
978
            bottom: 0,
979
            left: 0
980
        }, t)
981
    }
982
​
983
    function le(t, e) {
984
        return e.reduce((function(e, i) {
985
            return e[i] = t, e
986
        }), {})
987
    }
988
    const ce = {
989
        name: "arrow",
990
        enabled: !0,
991
        phase: "main",
992
        fn: function(t) {
993
            var e, i = t.state,
994
                n = t.name,
995
                s = t.options,
996
                o = i.elements.arrow,
997
                r = i.modifiersData.popperOffsets,
998
                a = qt(i.placement),
999
                l = oe(a),
1000
                c = [_t, gt].indexOf(a) >= 0 ? "height" : "width";
1001
            if (o && r) {
1002
                var h = function(t, e) {
1003
                        return ae("number" != typeof(t = "function" == typeof t ? t(Object.assign({}, e.rects, {
1004
                            placement: e.placement
1005
                        })) : t) ? t : le(t, vt))
1006
                    }(s.padding, i),
1007
                    d = Gt(o),
1008
                    u = "y" === l ? pt : _t,
1009
                    f = "y" === l ? mt : gt,
1010
                    p = i.rects.reference[c] + i.rects.reference[l] - r[l] - i.rects.popper[c],
1011
                    m = r[l] - i.rects.reference[l],
1012
                    g = se(o),
1013
                    _ = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0,
1014
                    b = p / 2 - m / 2,
1015
                    v = h[u],
1016
                    y = _ - d[c] - h[f],
1017
                    w = _ / 2 - d[c] / 2 + b,
1018
                    A = re(v, w, y),
1019
                    E = l;
1020
                i.modifiersData[n] = ((e = {})[E] = A, e.centerOffset = A - w, e)
1021
            }
1022
        },
1023
        effect: function(t) {
1024
            var e = t.state,
1025
                i = t.options.element,
1026
                n = void 0 === i ? "[data-popper-arrow]" : i;
1027
            null != n && ("string" != typeof n || (n = e.elements.popper.querySelector(n))) && Jt(e.elements.popper, n) && (e.elements.arrow = n)
1028
        },
1029
        requires: ["popperOffsets"],
1030
        requiresIfExists: ["preventOverflow"]
1031
    };
1032
​
1033
    function he(t) {
1034
        return t.split("-")[1]
1035
    }
1036
    var de = {
1037
        top: "auto",
1038
        right: "auto",
1039
        bottom: "auto",
1040
        left: "auto"
1041
    };
1042
​
1043
    function ue(t) {
1044
        var e, i = t.popper,
1045
            n = t.popperRect,
1046
            s = t.placement,
1047
            o = t.variation,
1048
            r = t.offsets,
1049
            a = t.position,
1050
            l = t.gpuAcceleration,
1051
            c = t.adaptive,
1052
            h = t.roundOffsets,
1053
            d = t.isFixed,
1054
            u = r.x,
1055
            f = void 0 === u ? 0 : u,
1056
            p = r.y,
1057
            m = void 0 === p ? 0 : p,
1058
            g = "function" == typeof h ? h({
1059
                x: f,
1060
                y: m
1061
            }) : {
1062
                x: f,
1063
                y: m
1064
            };
1065
        f = g.x, m = g.y;
1066
        var _ = r.hasOwnProperty("x"),
1067
            b = r.hasOwnProperty("y"),
1068
            v = _t,
1069
            y = pt,
1070
            w = window;
1071
        if (c) {
1072
            var A = se(i),
1073
                E = "clientHeight",
1074
                T = "clientWidth";
1075
            A === $t(i) && "static" !== Zt(A = ee(i)).position && "absolute" === a && (E = "scrollHeight", T = "scrollWidth"), (s === pt || (s === _t || s === gt) && o === wt) && (y = mt, m -= (d && A === w && w.visualViewport ? w.visualViewport.height : A[E]) - n.height, m *= l ? 1 : -1), s !== _t && (s !== pt && s !== mt || o !== wt) || (v = gt, f -= (d && A === w && w.visualViewport ? w.visualViewport.width : A[T]) - n.width, f *= l ? 1 : -1)
1076
        }
1077
        var C, O = Object.assign({
1078
                position: a
1079
            }, c && de),
1080
            x = !0 === h ? function(t) {
1081
                var e = t.x,
1082
                    i = t.y,
1083
                    n = window.devicePixelRatio || 1;
1084
                return {
1085
                    x: Qt(e * n) / n || 0,
1086
                    y: Qt(i * n) / n || 0
1087
                }
1088
            }({
1089
                x: f,
1090
                y: m
1091
            }) : {
1092
                x: f,
1093
                y: m
1094
            };
1095
        return f = x.x, m = x.y, l ? Object.assign({}, O, ((C = {})[y] = b ? "0" : "", C[v] = _ ? "0" : "", C.transform = (w.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", C)) : Object.assign({}, O, ((e = {})[y] = b ? m + "px" : "", e[v] = _ ? f + "px" : "", e.transform = "", e))
1096
    }
1097
    const fe = {
1098
        name: "computeStyles",
1099
        enabled: !0,
1100
        phase: "beforeWrite",
1101
        fn: function(t) {
1102
            var e = t.state,
1103
                i = t.options,
1104
                n = i.gpuAcceleration,
1105
                s = void 0 === n || n,
1106
                o = i.adaptive,
1107
                r = void 0 === o || o,
1108
                a = i.roundOffsets,
1109
                l = void 0 === a || a,
1110
                c = {
1111
                    placement: qt(e.placement),
1112
                    variation: he(e.placement),
1113
                    popper: e.elements.popper,
1114
                    popperRect: e.rects.popper,
1115
                    gpuAcceleration: s,
1116
                    isFixed: "fixed" === e.options.strategy
1117
                };
1118
            null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, ue(Object.assign({}, c, {
1119
                offsets: e.modifiersData.popperOffsets,
1120
                position: e.options.strategy,
1121
                adaptive: r,
1122
                roundOffsets: l
1123
            })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, ue(Object.assign({}, c, {
1124
                offsets: e.modifiersData.arrow,
1125
                position: "absolute",
1126
                adaptive: !1,
1127
                roundOffsets: l
1128
            })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
1129
                "data-popper-placement": e.placement
1130
            })
1131
        },
1132
        data: {}
1133
    };
1134
    var pe = {
1135
        passive: !0
1136
    };
1137
    const me = {
1138
        name: "eventListeners",
1139
        enabled: !0,
1140
        phase: "write",
1141
        fn: function() {},
1142
        effect: function(t) {
1143
            var e = t.state,
1144
                i = t.instance,
1145
                n = t.options,
1146
                s = n.scroll,
1147
                o = void 0 === s || s,
1148
                r = n.resize,
1149
                a = void 0 === r || r,
1150
                l = $t(e.elements.popper),
1151
                c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
1152
            return o && c.forEach((function(t) {
1153
                    t.addEventListener("scroll", i.update, pe)
1154
                })), a && l.addEventListener("resize", i.update, pe),
1155
                function() {
1156
                    o && c.forEach((function(t) {
1157
                        t.removeEventListener("scroll", i.update, pe)
1158
                    })), a && l.removeEventListener("resize", i.update, pe)
1159
                }
1160
        },
1161
        data: {}
1162
    };
1163
    var ge = {
1164
        left: "right",
1165
        right: "left",
1166
        bottom: "top",
1167
        top: "bottom"
1168
    };
1169
​
1170
    function _e(t) {
1171
        return t.replace(/left|right|bottom|top/g, (function(t) {
1172
            return ge[t]
1173
        }))
1174
    }
1175
    var be = {
1176
        start: "end",
1177
        end: "start"
1178
    };
1179
​
1180
    function ve(t) {
1181
        return t.replace(/start|end/g, (function(t) {
1182
            return be[t]
1183
        }))
1184
    }
1185
​
1186
    function ye(t) {
1187
        var e = $t(t);
1188
        return {
1189
            scrollLeft: e.pageXOffset,
1190
            scrollTop: e.pageYOffset
1191
        }
1192
    }
1193
​
1194
    function we(t) {
1195
        return Ut(ee(t)).left + ye(t).scrollLeft
1196
    }
1197
​
1198
    function Ae(t) {
1199
        var e = Zt(t),
1200
            i = e.overflow,
1201
            n = e.overflowX,
1202
            s = e.overflowY;
1203
        return /auto|scroll|overlay|hidden/.test(i + s + n)
1204
    }
1205
​
1206
    function Ee(t) {
1207
        return ["html", "body", "#document"].indexOf(Ht(t)) >= 0 ? t.ownerDocument.body : Bt(t) && Ae(t) ? t : Ee(ie(t))
1208
    }
1209
​
1210
    function Te(t, e) {
1211
        var i;
1212
        void 0 === e && (e = []);
1213
        var n = Ee(t),
1214
            s = n === (null == (i = t.ownerDocument) ? void 0 : i.body),
1215
            o = $t(n),
1216
            r = s ? [o].concat(o.visualViewport || [], Ae(n) ? n : []) : n,
1217
            a = e.concat(r);
1218
        return s ? a : a.concat(Te(ie(r)))
1219
    }
1220
​
1221
    function Ce(t) {
1222
        return Object.assign({}, t, {
1223
            left: t.x,
1224
            top: t.y,
1225
            right: t.x + t.width,
1226
            bottom: t.y + t.height
1227
        })
1228
    }
1229
​
1230
    function Oe(t, e, i) {
1231
        return e === Et ? Ce(function(t, e) {
1232
            var i = $t(t),
1233
                n = ee(t),
1234
                s = i.visualViewport,
1235
                o = n.clientWidth,
1236
                r = n.clientHeight,
1237
                a = 0,
1238
                l = 0;
1239
            if (s) {
1240
                o = s.width, r = s.height;
1241
                var c = Yt();
1242
                (c || !c && "fixed" === e) && (a = s.offsetLeft, l = s.offsetTop)
1243
            }
1244
            return {
1245
                width: o,
1246
                height: r,
1247
                x: a + we(t),
1248
                y: l
1249
            }
1250
        }(t, i)) : Wt(e) ? function(t, e) {
1251
            var i = Ut(t, !1, "fixed" === e);
1252
            return i.top = i.top + t.clientTop, i.left = i.left + t.clientLeft, i.bottom = i.top + t.clientHeight, i.right = i.left + t.clientWidth, i.width = t.clientWidth, i.height = t.clientHeight, i.x = i.left, i.y = i.top, i
1253
        }(e, i) : Ce(function(t) {
1254
            var e, i = ee(t),
1255
                n = ye(t),
1256
                s = null == (e = t.ownerDocument) ? void 0 : e.body,
1257
                o = Vt(i.scrollWidth, i.clientWidth, s ? s.scrollWidth : 0, s ? s.clientWidth : 0),
1258
                r = Vt(i.scrollHeight, i.clientHeight, s ? s.scrollHeight : 0, s ? s.clientHeight : 0),
1259
                a = -n.scrollLeft + we(t),
1260
                l = -n.scrollTop;
1261
            return "rtl" === Zt(s || i).direction && (a += Vt(i.clientWidth, s ? s.clientWidth : 0) - o), {
1262
                width: o,
1263
                height: r,
1264
                x: a,
1265
                y: l
1266
            }
1267
        }(ee(t)))
1268
    }
1269
​
1270
    function xe(t) {
1271
        var e, i = t.reference,
1272
            n = t.element,
1273
            s = t.placement,
1274
            o = s ? qt(s) : null,
1275
            r = s ? he(s) : null,
1276
            a = i.x + i.width / 2 - n.width / 2,
1277
            l = i.y + i.height / 2 - n.height / 2;
1278
        switch (o) {
1279
            case pt:
1280
                e = {
1281
                    x: a,
1282
                    y: i.y - n.height
1283
                };
1284
                break;
1285
            case mt:
1286
                e = {
1287
                    x: a,
1288
                    y: i.y + i.height
1289
                };
1290
                break;
1291
            case gt:
1292
                e = {
1293
                    x: i.x + i.width,
1294
                    y: l
1295
                };
1296
                break;
1297
            case _t:
1298
                e = {
1299
                    x: i.x - n.width,
1300
                    y: l
1301
                };
1302
                break;
1303
            default:
1304
                e = {
1305
                    x: i.x,
1306
                    y: i.y
1307
                }
1308
        }
1309
        var c = o ? oe(o) : null;
1310
        if (null != c) {
1311
            var h = "y" === c ? "height" : "width";
1312
            switch (r) {
1313
                case yt:
1314
                    e[c] = e[c] - (i[h] / 2 - n[h] / 2);
1315
                    break;
1316
                case wt:
1317
                    e[c] = e[c] + (i[h] / 2 - n[h] / 2)
1318
            }
1319
        }
1320
        return e
1321
    }
1322
​
1323
    function ke(t, e) {
1324
        void 0 === e && (e = {});
1325
        var i = e,
1326
            n = i.placement,
1327
            s = void 0 === n ? t.placement : n,
1328
            o = i.strategy,
1329
            r = void 0 === o ? t.strategy : o,
1330
            a = i.boundary,
1331
            l = void 0 === a ? At : a,
1332
            c = i.rootBoundary,
1333
            h = void 0 === c ? Et : c,
1334
            d = i.elementContext,
1335
            u = void 0 === d ? Tt : d,
1336
            f = i.altBoundary,
1337
            p = void 0 !== f && f,
1338
            m = i.padding,
1339
            g = void 0 === m ? 0 : m,
1340
            _ = ae("number" != typeof g ? g : le(g, vt)),
1341
            b = u === Tt ? Ct : Tt,
1342
            v = t.rects.popper,
1343
            y = t.elements[p ? b : u],
1344
            w = function(t, e, i, n) {
1345
                var s = "clippingParents" === e ? function(t) {
1346
                        var e = Te(ie(t)),
1347
                            i = ["absolute", "fixed"].indexOf(Zt(t).position) >= 0 && Bt(t) ? se(t) : t;
1348
                        return Wt(i) ? e.filter((function(t) {
1349
                            return Wt(t) && Jt(t, i) && "body" !== Ht(t)
1350
                        })) : []
1351
                    }(t) : [].concat(e),
1352
                    o = [].concat(s, [i]),
1353
                    r = o[0],
1354
                    a = o.reduce((function(e, i) {
1355
                        var s = Oe(t, i, n);
1356
                        return e.top = Vt(s.top, e.top), e.right = Kt(s.right, e.right), e.bottom = Kt(s.bottom, e.bottom), e.left = Vt(s.left, e.left), e
1357
                    }), Oe(t, r, n));
1358
                return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a
1359
            }(Wt(y) ? y : y.contextElement || ee(t.elements.popper), l, h, r),
1360
            A = Ut(t.elements.reference),
1361
            E = xe({
1362
                reference: A,
1363
                element: v,
1364
                strategy: "absolute",
1365
                placement: s
1366
            }),
1367
            T = Ce(Object.assign({}, v, E)),
1368
            C = u === Tt ? T : A,
1369
            O = {
1370
                top: w.top - C.top + _.top,
1371
                bottom: C.bottom - w.bottom + _.bottom,
1372
                left: w.left - C.left + _.left,
1373
                right: C.right - w.right + _.right
1374
            },
1375
            x = t.modifiersData.offset;
1376
        if (u === Tt && x) {
1377
            var k = x[s];
1378
            Object.keys(O).forEach((function(t) {
1379
                var e = [gt, mt].indexOf(t) >= 0 ? 1 : -1,
1380
                    i = [pt, mt].indexOf(t) >= 0 ? "y" : "x";
1381
                O[t] += k[i] * e
1382
            }))
1383
        }
1384
        return O
1385
    }
1386
​
1387
    function Le(t, e) {
1388
        void 0 === e && (e = {});
1389
        var i = e,
1390
            n = i.placement,
1391
            s = i.boundary,
1392
            o = i.rootBoundary,
1393
            r = i.padding,
1394
            a = i.flipVariations,
1395
            l = i.allowedAutoPlacements,
1396
            c = void 0 === l ? xt : l,
1397
            h = he(n),
1398
            d = h ? a ? Ot : Ot.filter((function(t) {
1399
                return he(t) === h
1400
            })) : vt,
1401
            u = d.filter((function(t) {
1402
                return c.indexOf(t) >= 0
1403
            }));
1404
        0 === u.length && (u = d);
1405
        var f = u.reduce((function(e, i) {
1406
            return e[i] = ke(t, {
1407
                placement: i,
1408
                boundary: s,
1409
                rootBoundary: o,
1410
                padding: r
1411
            })[qt(i)], e
1412
        }), {});
1413
        return Object.keys(f).sort((function(t, e) {
1414
            return f[t] - f[e]
1415
        }))
1416
    }
1417
    const Se = {
1418
        name: "flip",
1419
        enabled: !0,
1420
        phase: "main",
1421
        fn: function(t) {
1422
            var e = t.state,
1423
                i = t.options,
1424
                n = t.name;
1425
            if (!e.modifiersData[n]._skip) {
1426
                for (var s = i.mainAxis, o = void 0 === s || s, r = i.altAxis, a = void 0 === r || r, l = i.fallbackPlacements, c = i.padding, h = i.boundary, d = i.rootBoundary, u = i.altBoundary, f = i.flipVariations, p = void 0 === f || f, m = i.allowedAutoPlacements, g = e.options.placement, _ = qt(g), b = l || (_ !== g && p ? function(t) {
1427
                        if (qt(t) === bt) return [];
1428
                        var e = _e(t);
1429
                        return [ve(t), e, ve(e)]
1430
                    }(g) : [_e(g)]), v = [g].concat(b).reduce((function(t, i) {
1431
                        return t.concat(qt(i) === bt ? Le(e, {
1432
                            placement: i,
1433
                            boundary: h,
1434
                            rootBoundary: d,
1435
                            padding: c,
1436
                            flipVariations: p,
1437
                            allowedAutoPlacements: m
1438
                        }) : i)
1439
                    }), []), y = e.rects.reference, w = e.rects.popper, A = new Map, E = !0, T = v[0], C = 0; C < v.length; C++) {
1440
                    var O = v[C],
1441
                        x = qt(O),
1442
                        k = he(O) === yt,
1443
                        L = [pt, mt].indexOf(x) >= 0,
1444
                        S = L ? "width" : "height",
1445
                        D = ke(e, {
1446
                            placement: O,
1447
                            boundary: h,
1448
                            rootBoundary: d,
1449
                            altBoundary: u,
1450
                            padding: c
1451
                        }),
1452
                        I = L ? k ? gt : _t : k ? mt : pt;
1453
                    y[S] > w[S] && (I = _e(I));
1454
                    var N = _e(I),
1455
                        P = [];
1456
                    if (o && P.push(D[x] <= 0), a && P.push(D[I] <= 0, D[N] <= 0), P.every((function(t) {
1457
                            return t
1458
                        }))) {
1459
                        T = O, E = !1;
1460
                        break
1461
                    }
1462
                    A.set(O, P)
1463
                }
1464
                if (E)
1465
                    for (var j = function(t) {
1466
                            var e = v.find((function(e) {
1467
                                var i = A.get(e);
1468
                                if (i) return i.slice(0, t).every((function(t) {
1469
                                    return t
1470
                                }))
1471
                            }));
1472
                            if (e) return T = e, "break"
1473
                        }, M = p ? 3 : 1; M > 0 && "break" !== j(M); M--);
1474
                e.placement !== T && (e.modifiersData[n]._skip = !0, e.placement = T, e.reset = !0)
1475
            }
1476
        },
1477
        requiresIfExists: ["offset"],
1478
        data: {
1479
            _skip: !1
1480
        }
1481
    };
1482
​
1483
    function De(t, e, i) {
1484
        return void 0 === i && (i = {
1485
            x: 0,
1486
            y: 0
1487
        }), {
1488
            top: t.top - e.height - i.y,
1489
            right: t.right - e.width + i.x,
1490
            bottom: t.bottom - e.height + i.y,
1491
            left: t.left - e.width - i.x
1492
        }
1493
    }
1494
​
1495
    function Ie(t) {
1496
        return [pt, gt, mt, _t].some((function(e) {
1497
            return t[e] >= 0
1498
        }))
1499
    }
1500
    const Ne = {
1501
            name: "hide",
1502
            enabled: !0,
1503
            phase: "main",
1504
            requiresIfExists: ["preventOverflow"],
1505
            fn: function(t) {
1506
                var e = t.state,
1507
                    i = t.name,
1508
                    n = e.rects.reference,
1509
                    s = e.rects.popper,
1510
                    o = e.modifiersData.preventOverflow,
1511
                    r = ke(e, {
1512
                        elementContext: "reference"
1513
                    }),
1514
                    a = ke(e, {
1515
                        altBoundary: !0
1516
                    }),
1517
                    l = De(r, n),
1518
                    c = De(a, s, o),
1519
                    h = Ie(l),
1520
                    d = Ie(c);
1521
                e.modifiersData[i] = {
1522
                    referenceClippingOffsets: l,
1523
                    popperEscapeOffsets: c,
1524
                    isReferenceHidden: h,
1525
                    hasPopperEscaped: d
1526
                }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
1527
                    "data-popper-reference-hidden": h,
1528
                    "data-popper-escaped": d
1529
                })
1530
            }
1531
        },
1532
        Pe = {
1533
            name: "offset",
1534
            enabled: !0,
1535
            phase: "main",
1536
            requires: ["popperOffsets"],
1537
            fn: function(t) {
1538
                var e = t.state,
1539
                    i = t.options,
1540
                    n = t.name,
1541
                    s = i.offset,
1542
                    o = void 0 === s ? [0, 0] : s,
1543
                    r = xt.reduce((function(t, i) {
1544
                        return t[i] = function(t, e, i) {
1545
                            var n = qt(t),
1546
                                s = [_t, pt].indexOf(n) >= 0 ? -1 : 1,
1547
                                o = "function" == typeof i ? i(Object.assign({}, e, {
1548
                                    placement: t
1549
                                })) : i,
1550
                                r = o[0],
1551
                                a = o[1];
1552
                            return r = r || 0, a = (a || 0) * s, [_t, gt].indexOf(n) >= 0 ? {
1553
                                x: a,
1554
                                y: r
1555
                            } : {
1556
                                x: r,
1557
                                y: a
1558
                            }
1559
                        }(i, e.rects, o), t
1560
                    }), {}),
1561
                    a = r[e.placement],
1562
                    l = a.x,
1563
                    c = a.y;
1564
                null != e.modifiersData.popperOffsets && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[n] = r
1565
            }
1566
        },
1567
        je = {
1568
            name: "popperOffsets",
1569
            enabled: !0,
1570
            phase: "read",
1571
            fn: function(t) {
1572
                var e = t.state,
1573
                    i = t.name;
1574
                e.modifiersData[i] = xe({
1575
                    reference: e.rects.reference,
1576
                    element: e.rects.popper,
1577
                    strategy: "absolute",
1578
                    placement: e.placement
1579
                })
1580
            },
1581
            data: {}
1582
        },
1583
        Me = {
1584
            name: "preventOverflow",
1585
            enabled: !0,
1586
            phase: "main",
1587
            fn: function(t) {
1588
                var e = t.state,
1589
                    i = t.options,
1590
                    n = t.name,
1591
                    s = i.mainAxis,
1592
                    o = void 0 === s || s,
1593
                    r = i.altAxis,
1594
                    a = void 0 !== r && r,
1595
                    l = i.boundary,
1596
                    c = i.rootBoundary,
1597
                    h = i.altBoundary,
1598
                    d = i.padding,
1599
                    u = i.tether,
1600
                    f = void 0 === u || u,
1601
                    p = i.tetherOffset,
1602
                    m = void 0 === p ? 0 : p,
1603
                    g = ke(e, {
1604
                        boundary: l,
1605
                        rootBoundary: c,
1606
                        padding: d,
1607
                        altBoundary: h
1608
                    }),
1609
                    _ = qt(e.placement),
1610
                    b = he(e.placement),
1611
                    v = !b,
1612
                    y = oe(_),
1613
                    w = "x" === y ? "y" : "x",
1614
                    A = e.modifiersData.popperOffsets,
1615
                    E = e.rects.reference,
1616
                    T = e.rects.popper,
1617
                    C = "function" == typeof m ? m(Object.assign({}, e.rects, {
1618
                        placement: e.placement
1619
                    })) : m,
1620
                    O = "number" == typeof C ? {
1621
                        mainAxis: C,
1622
                        altAxis: C
1623
                    } : Object.assign({
1624
                        mainAxis: 0,
1625
                        altAxis: 0
1626
                    }, C),
1627
                    x = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null,
1628
                    k = {
1629
                        x: 0,
1630
                        y: 0
1631
                    };
1632
                if (A) {
1633
                    if (o) {
1634
                        var L, S = "y" === y ? pt : _t,
1635
                            D = "y" === y ? mt : gt,
1636
                            I = "y" === y ? "height" : "width",
1637
                            N = A[y],
1638
                            P = N + g[S],
1639
                            j = N - g[D],
1640
                            M = f ? -T[I] / 2 : 0,
1641
                            F = b === yt ? E[I] : T[I],
1642
                            H = b === yt ? -T[I] : -E[I],
1643
                            $ = e.elements.arrow,
1644
                            W = f && $ ? Gt($) : {
1645
                                width: 0,
1646
                                height: 0
1647
                            },
1648
                            B = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : {
1649
                                top: 0,
1650
                                right: 0,
1651
                                bottom: 0,
1652
                                left: 0
1653
                            },
1654
                            z = B[S],
1655
                            R = B[D],
1656
                            q = re(0, E[I], W[I]),
1657
                            V = v ? E[I] / 2 - M - q - z - O.mainAxis : F - q - z - O.mainAxis,
1658
                            K = v ? -E[I] / 2 + M + q + R + O.mainAxis : H + q + R + O.mainAxis,
1659
                            Q = e.elements.arrow && se(e.elements.arrow),
1660
                            X = Q ? "y" === y ? Q.clientTop || 0 : Q.clientLeft || 0 : 0,
1661
                            Y = null != (L = null == x ? void 0 : x[y]) ? L : 0,
1662
                            U = N + K - Y,
1663
                            G = re(f ? Kt(P, N + V - Y - X) : P, N, f ? Vt(j, U) : j);
1664
                        A[y] = G, k[y] = G - N
1665
                    }
1666
                    if (a) {
1667
                        var J, Z = "x" === y ? pt : _t,
1668
                            tt = "x" === y ? mt : gt,
1669
                            et = A[w],
1670
                            it = "y" === w ? "height" : "width",
1671
                            nt = et + g[Z],
1672
                            st = et - g[tt],
1673
                            ot = -1 !== [pt, _t].indexOf(_),
1674
                            rt = null != (J = null == x ? void 0 : x[w]) ? J : 0,
1675
                            at = ot ? nt : et - E[it] - T[it] - rt + O.altAxis,
1676
                            lt = ot ? et + E[it] + T[it] - rt - O.altAxis : st,
1677
                            ct = f && ot ? function(t, e, i) {
1678
                                var n = re(t, e, i);
1679
                                return n > i ? i : n
1680
                            }(at, et, lt) : re(f ? at : nt, et, f ? lt : st);
1681
                        A[w] = ct, k[w] = ct - et
1682
                    }
1683
                    e.modifiersData[n] = k
1684
                }
1685
            },
1686
            requiresIfExists: ["offset"]
1687
        };
1688
​
1689
    function Fe(t, e, i) {
1690
        void 0 === i && (i = !1);
1691
        var n, s, o = Bt(e),
1692
            r = Bt(e) && function(t) {
1693
                var e = t.getBoundingClientRect(),
1694
                    i = Qt(e.width) / t.offsetWidth || 1,
1695
                    n = Qt(e.height) / t.offsetHeight || 1;
1696
                return 1 !== i || 1 !== n
1697
            }(e),
1698
            a = ee(e),
1699
            l = Ut(t, r, i),
1700
            c = {
1701
                scrollLeft: 0,
1702
                scrollTop: 0
1703
            },
1704
            h = {
1705
                x: 0,
1706
                y: 0
1707
            };
1708
        return (o || !o && !i) && (("body" !== Ht(e) || Ae(a)) && (c = (n = e) !== $t(n) && Bt(n) ? {
1709
            scrollLeft: (s = n).scrollLeft,
1710
            scrollTop: s.scrollTop
1711
        } : ye(n)), Bt(e) ? ((h = Ut(e, !0)).x += e.clientLeft, h.y += e.clientTop) : a && (h.x = we(a))), {
1712
            x: l.left + c.scrollLeft - h.x,
1713
            y: l.top + c.scrollTop - h.y,
1714
            width: l.width,
1715
            height: l.height
1716
        }
1717
    }
1718
​
1719
    function He(t) {
1720
        var e = new Map,
1721
            i = new Set,
1722
            n = [];
1723
​
1724
        function s(t) {
1725
            i.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach((function(t) {
1726
                if (!i.has(t)) {
1727
                    var n = e.get(t);
1728
                    n && s(n)
1729
                }
1730
            })), n.push(t)
1731
        }
1732
        return t.forEach((function(t) {
1733
            e.set(t.name, t)
1734
        })), t.forEach((function(t) {
1735
            i.has(t.name) || s(t)
1736
        })), n
1737
    }
1738
    var $e = {
1739
        placement: "bottom",
1740
        modifiers: [],
1741
        strategy: "absolute"
1742
    };
1743
​
1744
    function We() {
1745
        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
1746
        return !e.some((function(t) {
1747
            return !(t && "function" == typeof t.getBoundingClientRect)
1748
        }))
1749
    }
1750
​
1751
    function Be(t) {
1752
        void 0 === t && (t = {});
1753
        var e = t,
1754
            i = e.defaultModifiers,
1755
            n = void 0 === i ? [] : i,
1756
            s = e.defaultOptions,
1757
            o = void 0 === s ? $e : s;
1758
        return function(t, e, i) {
1759
            void 0 === i && (i = o);
1760
            var s, r, a = {
1761
                    placement: "bottom",
1762
                    orderedModifiers: [],
1763
                    options: Object.assign({}, $e, o),
1764
                    modifiersData: {},
1765
                    elements: {
1766
                        reference: t,
1767
                        popper: e
1768
                    },
1769
                    attributes: {},
1770
                    styles: {}
1771
                },
1772
                l = [],
1773
                c = !1,
1774
                h = {
1775
                    state: a,
1776
                    setOptions: function(i) {
1777
                        var s = "function" == typeof i ? i(a.options) : i;
1778
                        d(), a.options = Object.assign({}, o, a.options, s), a.scrollParents = {
1779
                            reference: Wt(t) ? Te(t) : t.contextElement ? Te(t.contextElement) : [],
1780
                            popper: Te(e)
1781
                        };
1782
                        var r, c, u = function(t) {
1783
                            var e = He(t);
1784
                            return Ft.reduce((function(t, i) {
1785
                                return t.concat(e.filter((function(t) {
1786
                                    return t.phase === i
1787
                                })))
1788
                            }), [])
1789
                        }((r = [].concat(n, a.options.modifiers), c = r.reduce((function(t, e) {
1790
                            var i = t[e.name];
1791
                            return t[e.name] = i ? Object.assign({}, i, e, {
1792
                                options: Object.assign({}, i.options, e.options),
1793
                                data: Object.assign({}, i.data, e.data)
1794
                            }) : e, t
1795
                        }), {}), Object.keys(c).map((function(t) {
1796
                            return c[t]
1797
                        }))));
1798
                        return a.orderedModifiers = u.filter((function(t) {
1799
                            return t.enabled
1800
                        })), a.orderedModifiers.forEach((function(t) {
1801
                            var e = t.name,
1802
                                i = t.options,
1803
                                n = void 0 === i ? {} : i,
1804
                                s = t.effect;
1805
                            if ("function" == typeof s) {
1806
                                var o = s({
1807
                                    state: a,
1808
                                    name: e,
1809
                                    instance: h,
1810
                                    options: n
1811
                                });
1812
                                l.push(o || function() {})
1813
                            }
1814
                        })), h.update()
1815
                    },
1816
                    forceUpdate: function() {
1817
                        if (!c) {
1818
                            var t = a.elements,
1819
                                e = t.reference,
1820
                                i = t.popper;
1821
                            if (We(e, i)) {
1822
                                a.rects = {
1823
                                    reference: Fe(e, se(i), "fixed" === a.options.strategy),
1824
                                    popper: Gt(i)
1825
                                }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function(t) {
1826
                                    return a.modifiersData[t.name] = Object.assign({}, t.data)
1827
                                }));
1828
                                for (var n = 0; n < a.orderedModifiers.length; n++)
1829
                                    if (!0 !== a.reset) {
1830
                                        var s = a.orderedModifiers[n],
1831
                                            o = s.fn,
1832
                                            r = s.options,
1833
                                            l = void 0 === r ? {} : r,
1834
                                            d = s.name;
1835
                                        "function" == typeof o && (a = o({
1836
                                            state: a,
1837
                                            options: l,
1838
                                            name: d,
1839
                                            instance: h
1840
                                        }) || a)
1841
                                    } else a.reset = !1, n = -1
1842
                            }
1843
                        }
1844
                    },
1845
                    update: (s = function() {
1846
                        return new Promise((function(t) {
1847
                            h.forceUpdate(), t(a)
1848
                        }))
1849
                    }, function() {
1850
                        return r || (r = new Promise((function(t) {
1851
                            Promise.resolve().then((function() {
1852
                                r = void 0, t(s())
1853
                            }))
1854
                        }))), r
1855
                    }),
1856
                    destroy: function() {
1857
                        d(), c = !0
1858
                    }
1859
                };
1860
            if (!We(t, e)) return h;
1861
​
1862
            function d() {
1863
                l.forEach((function(t) {
1864
                    return t()
1865
                })), l = []
1866
            }
1867
            return h.setOptions(i).then((function(t) {
1868
                !c && i.onFirstUpdate && i.onFirstUpdate(t)
1869
            })), h
1870
        }
1871
    }
1872
    var ze = Be(),
1873
        Re = Be({
1874
            defaultModifiers: [me, je, fe, Rt]
1875
        }),
1876
        qe = Be({
1877
            defaultModifiers: [me, je, fe, Rt, Pe, Se, Me, ce, Ne]
1878
        });
1879
    const Ve = Object.freeze(Object.defineProperty({
1880
            __proto__: null,
1881
            popperGenerator: Be,
1882
            detectOverflow: ke,
1883
            createPopperBase: ze,
1884
            createPopper: qe,
1885
            createPopperLite: Re,
1886
            top: pt,
1887
            bottom: mt,
1888
            right: gt,
1889
            left: _t,
1890
            auto: bt,
1891
            basePlacements: vt,
1892
            start: yt,
1893
            end: wt,
1894
            clippingParents: At,
1895
            viewport: Et,
1896
            popper: Tt,
1897
            reference: Ct,
1898
            variationPlacements: Ot,
1899
            placements: xt,
1900
            beforeRead: kt,
1901
            read: Lt,
1902
            afterRead: St,
1903
            beforeMain: Dt,
1904
            main: It,
1905
            afterMain: Nt,
1906
            beforeWrite: Pt,
1907
            write: jt,
1908
            afterWrite: Mt,
1909
            modifierPhases: Ft,
1910
            applyStyles: Rt,
1911
            arrow: ce,
1912
            computeStyles: fe,
1913
            eventListeners: me,
1914
            flip: Se,
1915
            hide: Ne,
1916
            offset: Pe,
1917
            popperOffsets: je,
1918
            preventOverflow: Me
1919
        }, Symbol.toStringTag, {
1920
            value: "Module"
1921
        })),
1922
        Ke = "dropdown",
1923
        Qe = "ArrowUp",
1924
        Xe = "ArrowDown",
1925
        Ye = "click.bs.dropdown.data-api",
1926
        Ue = "keydown.bs.dropdown.data-api",
1927
        Ge = "show",
1928
        Je = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
1929
        Ze = `${Je}.show`,
1930
        ti = ".dropdown-menu",
1931
        ei = u() ? "top-end" : "top-start",
1932
        ii = u() ? "top-start" : "top-end",
1933
        ni = u() ? "bottom-end" : "bottom-start",
1934
        si = u() ? "bottom-start" : "bottom-end",
1935
        oi = u() ? "left-start" : "right-start",
1936
        ri = u() ? "right-start" : "left-start",
1937
        ai = {
1938
            autoClose: !0,
1939
            boundary: "clippingParents",
1940
            display: "dynamic",
1941
            offset: [0, 2],
1942
            popperConfig: null,
1943
            reference: "toggle"
1944
        },
1945
        li = {
1946
            autoClose: "(boolean|string)",
1947
            boundary: "(string|element)",
1948
            display: "string",
1949
            offset: "(array|string|function)",
1950
            popperConfig: "(null|object|function)",
1951
            reference: "(string|element|object)"
1952
        };
1953
    class ci extends W {
1954
        constructor(t, e) {
1955
            super(t, e), this._popper = null, this._parent = this._element.parentNode, this._menu = z.next(this._element, ti)[0] || z.prev(this._element, ti)[0] || z.findOne(ti, this._parent), this._inNavbar = this._detectNavbar()
1956
        }
1957
        static get Default() {
1958
            return ai
1959
        }
1960
        static get DefaultType() {
1961
            return li
1962
        }
1963
        static get NAME() {
1964
            return Ke
1965
        }
1966
        toggle() {
1967
            return this._isShown() ? this.hide() : this.show()
1968
        }
1969
        show() {
1970
            if (r(this._element) || this._isShown()) return;
1971
            const t = {
1972
                relatedTarget: this._element
1973
            };
1974
            if (!I.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
1975
                if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav"))
1976
                    for (const t of [].concat(...document.body.children)) I.on(t, "mouseover", l);
1977
                this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(Ge), this._element.classList.add(Ge), I.trigger(this._element, "shown.bs.dropdown", t)
1978
            }
1979
        }
1980
        hide() {
1981
            if (r(this._element) || !this._isShown()) return;
1982
            const t = {
1983
                relatedTarget: this._element
1984
            };
1985
            this._completeHide(t)
1986
        }
1987
        dispose() {
1988
            this._popper && this._popper.destroy(), super.dispose()
1989
        }
1990
        update() {
1991
            this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
1992
        }
1993
        _completeHide(t) {
1994
            if (!I.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented) {
1995
                if ("ontouchstart" in document.documentElement)
1996
                    for (const t of [].concat(...document.body.children)) I.off(t, "mouseover", l);
1997
                this._popper && this._popper.destroy(), this._menu.classList.remove(Ge), this._element.classList.remove(Ge), this._element.setAttribute("aria-expanded", "false"), H.removeDataAttribute(this._menu, "popper"), I.trigger(this._element, "hidden.bs.dropdown", t)
1998
            }
1999
        }
2000
        _getConfig(t) {
2001
            if ("object" == typeof(t = super._getConfig(t)).reference && !n(t.reference) && "function" != typeof t.reference.getBoundingClientRect) throw new TypeError(`${Ke.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
2002
            return t
2003
        }
2004
        _createPopper() {
2005
            if (void 0 === Ve) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
2006
            let t = this._element;
2007
            "parent" === this._config.reference ? t = this._parent : n(this._config.reference) ? t = s(this._config.reference) : "object" == typeof this._config.reference && (t = this._config.reference);
2008
            const e = this._getPopperConfig();
2009
            this._popper = qe(t, this._menu, e)
2010
        }
2011
        _isShown() {
2012
            return this._menu.classList.contains(Ge)
2013
        }
2014
        _getPlacement() {
2015
            const t = this._parent;
2016
            if (t.classList.contains("dropend")) return oi;
2017
            if (t.classList.contains("dropstart")) return ri;
2018
            if (t.classList.contains("dropup-center")) return "top";
2019
            if (t.classList.contains("dropdown-center")) return "bottom";
2020
            const e = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
2021
            return t.classList.contains("dropup") ? e ? ii : ei : e ? si : ni
2022
        }
2023
        _detectNavbar() {
2024
            return null !== this._element.closest(".navbar")
2025
        }
2026
        _getOffset() {
2027
            const {
2028
                offset: t
2029
            } = this._config;
2030
            return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
2031
        }
2032
        _getPopperConfig() {
2033
            const t = {
2034
                placement: this._getPlacement(),
2035
                modifiers: [{
2036
                    name: "preventOverflow",
2037
                    options: {
2038
                        boundary: this._config.boundary
2039
                    }
2040
                }, {
2041
                    name: "offset",
2042
                    options: {
2043
                        offset: this._getOffset()
2044
                    }
2045
                }]
2046
            };
2047
            return (this._inNavbar || "static" === this._config.display) && (H.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
2048
                name: "applyStyles",
2049
                enabled: !1
2050
            }]), {
2051
                ...t,
2052
                ...p(this._config.popperConfig, [t])
2053
            }
2054
        }
2055
        _selectMenuItem({
2056
            key: t,
2057
            target: e
2058
        }) {
2059
            const i = z.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t => o(t)));
2060
            i.length && g(i, e, t === Xe, !i.includes(e)).focus()
2061
        }
2062
        static jQueryInterface(t) {
2063
            return this.each((function() {
2064
                const e = ci.getOrCreateInstance(this, t);
2065
                if ("string" == typeof t) {
2066
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
2067
                    e[t]()
2068
                }
2069
            }))
2070
        }
2071
        static clearMenus(t) {
2072
            if (2 === t.button || "keyup" === t.type && "Tab" !== t.key) return;
2073
            const e = z.find(Ze);
2074
            for (const i of e) {
2075
                const e = ci.getInstance(i);
2076
                if (!e || !1 === e._config.autoClose) continue;
2077
                const n = t.composedPath(),
2078
                    s = n.includes(e._menu);
2079
                if (n.includes(e._element) || "inside" === e._config.autoClose && !s || "outside" === e._config.autoClose && s) continue;
2080
                if (e._menu.contains(t.target) && ("keyup" === t.type && "Tab" === t.key || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
2081
                const o = {
2082
                    relatedTarget: e._element
2083
                };
2084
                "click" === t.type && (o.clickEvent = t), e._completeHide(o)
2085
            }
2086
        }
2087
        static dataApiKeydownHandler(t) {
2088
            const e = /input|textarea/i.test(t.target.tagName),
2089
                i = "Escape" === t.key,
2090
                n = [Qe, Xe].includes(t.key);
2091
            if (!n && !i) return;
2092
            if (e && !i) return;
2093
            t.preventDefault();
2094
            const s = this.matches(Je) ? this : z.prev(this, Je)[0] || z.next(this, Je)[0] || z.findOne(Je, t.delegateTarget.parentNode),
2095
                o = ci.getOrCreateInstance(s);
2096
            if (n) return t.stopPropagation(), o.show(), void o._selectMenuItem(t);
2097
            o._isShown() && (t.stopPropagation(), o.hide(), s.focus())
2098
        }
2099
    }
2100
    I.on(document, Ue, Je, ci.dataApiKeydownHandler), I.on(document, Ue, ti, ci.dataApiKeydownHandler), I.on(document, Ye, ci.clearMenus), I.on(document, "keyup.bs.dropdown.data-api", ci.clearMenus), I.on(document, Ye, Je, (function(t) {
2101
        t.preventDefault(), ci.getOrCreateInstance(this).toggle()
2102
    })), f(ci);
2103
    const hi = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
2104
        di = ".sticky-top",
2105
        ui = "padding-right",
2106
        fi = "margin-right";
2107
    class pi {
2108
        constructor() {
2109
            this._element = document.body
2110
        }
2111
        getWidth() {
2112
            const t = document.documentElement.clientWidth;
2113
            return Math.abs(window.innerWidth - t)
2114
        }
2115
        hide() {
2116
            const t = this.getWidth();
2117
            this._disableOverFlow(), this._setElementAttributes(this._element, ui, (e => e + t)), this._setElementAttributes(hi, ui, (e => e + t)), this._setElementAttributes(di, fi, (e => e - t))
2118
        }
2119
        reset() {
2120
            this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, ui), this._resetElementAttributes(hi, ui), this._resetElementAttributes(di, fi)
2121
        }
2122
        isOverflowing() {
2123
            return this.getWidth() > 0
2124
        }
2125
        _disableOverFlow() {
2126
            this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
2127
        }
2128
        _setElementAttributes(t, e, i) {
2129
            const n = this.getWidth();
2130
            this._applyManipulationCallback(t, (t => {
2131
                if (t !== this._element && window.innerWidth > t.clientWidth + n) return;
2132
                this._saveInitialAttribute(t, e);
2133
                const s = window.getComputedStyle(t).getPropertyValue(e);
2134
                t.style.setProperty(e, `${i(Number.parseFloat(s))}px`)
2135
            }))
2136
        }
2137
        _saveInitialAttribute(t, e) {
2138
            const i = t.style.getPropertyValue(e);
2139
            i && H.setDataAttribute(t, e, i)
2140
        }
2141
        _resetElementAttributes(t, e) {
2142
            this._applyManipulationCallback(t, (t => {
2143
                const i = H.getDataAttribute(t, e);
2144
                null !== i ? (H.removeDataAttribute(t, e), t.style.setProperty(e, i)) : t.style.removeProperty(e)
2145
            }))
2146
        }
2147
        _applyManipulationCallback(t, e) {
2148
            if (n(t)) e(t);
2149
            else
2150
                for (const i of z.find(t, this._element)) e(i)
2151
        }
2152
    }
2153
    const mi = "show",
2154
        gi = "mousedown.bs.backdrop",
2155
        _i = {
2156
            className: "modal-backdrop",
2157
            clickCallback: null,
2158
            isAnimated: !1,
2159
            isVisible: !0,
2160
            rootElement: "body"
2161
        },
2162
        bi = {
2163
            className: "string",
2164
            clickCallback: "(function|null)",
2165
            isAnimated: "boolean",
2166
            isVisible: "boolean",
2167
            rootElement: "(element|string)"
2168
        };
2169
    class vi extends $ {
2170
        constructor(t) {
2171
            super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null
2172
        }
2173
        static get Default() {
2174
            return _i
2175
        }
2176
        static get DefaultType() {
2177
            return bi
2178
        }
2179
        static get NAME() {
2180
            return "backdrop"
2181
        }
2182
        show(t) {
2183
            if (!this._config.isVisible) return void p(t);
2184
            this._append();
2185
            const e = this._getElement();
2186
            this._config.isAnimated && c(e), e.classList.add(mi), this._emulateAnimation((() => {
2187
                p(t)
2188
            }))
2189
        }
2190
        hide(t) {
2191
            this._config.isVisible ? (this._getElement().classList.remove(mi), this._emulateAnimation((() => {
2192
                this.dispose(), p(t)
2193
            }))) : p(t)
2194
        }
2195
        dispose() {
2196
            this._isAppended && (I.off(this._element, gi), this._element.remove(), this._isAppended = !1)
2197
        }
2198
        _getElement() {
2199
            if (!this._element) {
2200
                const t = document.createElement("div");
2201
                t.className = this._config.className, this._config.isAnimated && t.classList.add("fade"), this._element = t
2202
            }
2203
            return this._element
2204
        }
2205
        _configAfterMerge(t) {
2206
            return t.rootElement = s(t.rootElement), t
2207
        }
2208
        _append() {
2209
            if (this._isAppended) return;
2210
            const t = this._getElement();
2211
            this._config.rootElement.append(t), I.on(t, gi, (() => {
2212
                p(this._config.clickCallback)
2213
            })), this._isAppended = !0
2214
        }
2215
        _emulateAnimation(t) {
2216
            m(t, this._getElement(), this._config.isAnimated)
2217
        }
2218
    }
2219
    const yi = ".bs.focustrap",
2220
        wi = "backward",
2221
        Ai = {
2222
            autofocus: !0,
2223
            trapElement: null
2224
        },
2225
        Ei = {
2226
            autofocus: "boolean",
2227
            trapElement: "element"
2228
        };
2229
    class Ti extends $ {
2230
        constructor(t) {
2231
            super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null
2232
        }
2233
        static get Default() {
2234
            return Ai
2235
        }
2236
        static get DefaultType() {
2237
            return Ei
2238
        }
2239
        static get NAME() {
2240
            return "focustrap"
2241
        }
2242
        activate() {
2243
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(), I.off(document, yi), I.on(document, "focusin.bs.focustrap", (t => this._handleFocusin(t))), I.on(document, "keydown.tab.bs.focustrap", (t => this._handleKeydown(t))), this._isActive = !0)
2244
        }
2245
        deactivate() {
2246
            this._isActive && (this._isActive = !1, I.off(document, yi))
2247
        }
2248
        _handleFocusin(t) {
2249
            const {
2250
                trapElement: e
2251
            } = this._config;
2252
            if (t.target === document || t.target === e || e.contains(t.target)) return;
2253
            const i = z.focusableChildren(e);
2254
            0 === i.length ? e.focus() : this._lastTabNavDirection === wi ? i[i.length - 1].focus() : i[0].focus()
2255
        }
2256
        _handleKeydown(t) {
2257
            "Tab" === t.key && (this._lastTabNavDirection = t.shiftKey ? wi : "forward")
2258
        }
2259
    }
2260
    const Ci = "hidden.bs.modal",
2261
        Oi = "show.bs.modal",
2262
        xi = "modal-open",
2263
        ki = "show",
2264
        Li = "modal-static",
2265
        Si = {
2266
            backdrop: !0,
2267
            focus: !0,
2268
            keyboard: !0
2269
        },
2270
        Di = {
2271
            backdrop: "(boolean|string)",
2272
            focus: "boolean",
2273
            keyboard: "boolean"
2274
        };
2275
    class Ii extends W {
2276
        constructor(t, e) {
2277
            super(t, e), this._dialog = z.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new pi, this._addEventListeners()
2278
        }
2279
        static get Default() {
2280
            return Si
2281
        }
2282
        static get DefaultType() {
2283
            return Di
2284
        }
2285
        static get NAME() {
2286
            return "modal"
2287
        }
2288
        toggle(t) {
2289
            return this._isShown ? this.hide() : this.show(t)
2290
        }
2291
        show(t) {
2292
            this._isShown || this._isTransitioning || I.trigger(this._element, Oi, {
2293
                relatedTarget: t
2294
            }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(xi), this._adjustDialog(), this._backdrop.show((() => this._showElement(t))))
2295
        }
2296
        hide() {
2297
            this._isShown && !this._isTransitioning && (I.trigger(this._element, "hide.bs.modal").defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(ki), this._queueCallback((() => this._hideModal()), this._element, this._isAnimated())))
2298
        }
2299
        dispose() {
2300
            for (const t of [window, this._dialog]) I.off(t, ".bs.modal");
2301
            this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
2302
        }
2303
        handleUpdate() {
2304
            this._adjustDialog()
2305
        }
2306
        _initializeBackDrop() {
2307
            return new vi({
2308
                isVisible: Boolean(this._config.backdrop),
2309
                isAnimated: this._isAnimated()
2310
            })
2311
        }
2312
        _initializeFocusTrap() {
2313
            return new Ti({
2314
                trapElement: this._element
2315
            })
2316
        }
2317
        _showElement(t) {
2318
            document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
2319
            const e = z.findOne(".modal-body", this._dialog);
2320
            e && (e.scrollTop = 0), c(this._element), this._element.classList.add(ki), this._queueCallback((() => {
2321
                this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, I.trigger(this._element, "shown.bs.modal", {
2322
                    relatedTarget: t
2323
                })
2324
            }), this._dialog, this._isAnimated())
2325
        }
2326
        _addEventListeners() {
2327
            I.on(this._element, "keydown.dismiss.bs.modal", (t => {
2328
                if ("Escape" === t.key) return this._config.keyboard ? (t.preventDefault(), void this.hide()) : void this._triggerBackdropTransition()
2329
            })), I.on(window, "resize.bs.modal", (() => {
2330
                this._isShown && !this._isTransitioning && this._adjustDialog()
2331
            })), I.on(this._element, "mousedown.dismiss.bs.modal", (t => {
2332
                I.one(this._element, "click.dismiss.bs.modal", (e => {
2333
                    this._element === t.target && this._element === e.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition())
2334
                }))
2335
            }))
2336
        }
2337
        _hideModal() {
2338
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide((() => {
2339
                document.body.classList.remove(xi), this._resetAdjustments(), this._scrollBar.reset(), I.trigger(this._element, Ci)
2340
            }))
2341
        }
2342
        _isAnimated() {
2343
            return this._element.classList.contains("fade")
2344
        }
2345
        _triggerBackdropTransition() {
2346
            if (I.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented) return;
2347
            const t = this._element.scrollHeight > document.documentElement.clientHeight,
2348
                e = this._element.style.overflowY;
2349
            "hidden" === e || this._element.classList.contains(Li) || (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(Li), this._queueCallback((() => {
2350
                this._element.classList.remove(Li), this._queueCallback((() => {
2351
                    this._element.style.overflowY = e
2352
                }), this._dialog)
2353
            }), this._dialog), this._element.focus())
2354
        }
2355
        _adjustDialog() {
2356
            const t = this._element.scrollHeight > document.documentElement.clientHeight,
2357
                e = this._scrollBar.getWidth(),
2358
                i = e > 0;
2359
            if (i && !t) {
2360
                const t = u() ? "paddingLeft" : "paddingRight";
2361
                this._element.style[t] = `${e}px`
2362
            }
2363
            if (!i && t) {
2364
                const t = u() ? "paddingRight" : "paddingLeft";
2365
                this._element.style[t] = `${e}px`
2366
            }
2367
        }
2368
        _resetAdjustments() {
2369
            this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
2370
        }
2371
        static jQueryInterface(t, e) {
2372
            return this.each((function() {
2373
                const i = Ii.getOrCreateInstance(this, t);
2374
                if ("string" == typeof t) {
2375
                    if (void 0 === i[t]) throw new TypeError(`No method named "${t}"`);
2376
                    i[t](e)
2377
                }
2378
            }))
2379
        }
2380
    }
2381
    I.on(document, "click.bs.modal.data-api", '[data-bs-toggle="modal"]', (function(t) {
2382
        const e = z.getElementFromSelector(this);
2383
        ["A", "AREA"].includes(this.tagName) && t.preventDefault(), I.one(e, Oi, (t => {
2384
            t.defaultPrevented || I.one(e, Ci, (() => {
2385
                o(this) && this.focus()
2386
            }))
2387
        }));
2388
        const i = z.findOne(".modal.show");
2389
        i && Ii.getInstance(i).hide(), Ii.getOrCreateInstance(e).toggle(this)
2390
    })), R(Ii), f(Ii);
2391
    const Ni = "show",
2392
        Pi = "showing",
2393
        ji = "hiding",
2394
        Mi = ".offcanvas.show",
2395
        Fi = "hidePrevented.bs.offcanvas",
2396
        Hi = "hidden.bs.offcanvas",
2397
        $i = {
2398
            backdrop: !0,
2399
            keyboard: !0,
2400
            scroll: !1
2401
        },
2402
        Wi = {
2403
            backdrop: "(boolean|string)",
2404
            keyboard: "boolean",
2405
            scroll: "boolean"
2406
        };
2407
    class Bi extends W {
2408
        constructor(t, e) {
2409
            super(t, e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
2410
        }
2411
        static get Default() {
2412
            return $i
2413
        }
2414
        static get DefaultType() {
2415
            return Wi
2416
        }
2417
        static get NAME() {
2418
            return "offcanvas"
2419
        }
2420
        toggle(t) {
2421
            return this._isShown ? this.hide() : this.show(t)
2422
        }
2423
        show(t) {
2424
            this._isShown || I.trigger(this._element, "show.bs.offcanvas", {
2425
                relatedTarget: t
2426
            }).defaultPrevented || (this._isShown = !0, this._backdrop.show(), this._config.scroll || (new pi).hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Pi), this._queueCallback((() => {
2427
                this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Ni), this._element.classList.remove(Pi), I.trigger(this._element, "shown.bs.offcanvas", {
2428
                    relatedTarget: t
2429
                })
2430
            }), this._element, !0))
2431
        }
2432
        hide() {
2433
            this._isShown && (I.trigger(this._element, "hide.bs.offcanvas").defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(ji), this._backdrop.hide(), this._queueCallback((() => {
2434
                this._element.classList.remove(Ni, ji), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || (new pi).reset(), I.trigger(this._element, Hi)
2435
            }), this._element, !0)))
2436
        }
2437
        dispose() {
2438
            this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
2439
        }
2440
        _initializeBackDrop() {
2441
            const t = Boolean(this._config.backdrop);
2442
            return new vi({
2443
                className: "offcanvas-backdrop",
2444
                isVisible: t,
2445
                isAnimated: !0,
2446
                rootElement: this._element.parentNode,
2447
                clickCallback: t ? () => {
2448
                    "static" !== this._config.backdrop ? this.hide() : I.trigger(this._element, Fi)
2449
                } : null
2450
            })
2451
        }
2452
        _initializeFocusTrap() {
2453
            return new Ti({
2454
                trapElement: this._element
2455
            })
2456
        }
2457
        _addEventListeners() {
2458
            I.on(this._element, "keydown.dismiss.bs.offcanvas", (t => {
2459
                "Escape" === t.key && (this._config.keyboard ? this.hide() : I.trigger(this._element, Fi))
2460
            }))
2461
        }
2462
        static jQueryInterface(t) {
2463
            return this.each((function() {
2464
                const e = Bi.getOrCreateInstance(this, t);
2465
                if ("string" == typeof t) {
2466
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
2467
                    e[t](this)
2468
                }
2469
            }))
2470
        }
2471
    }
2472
    I.on(document, "click.bs.offcanvas.data-api", '[data-bs-toggle="offcanvas"]', (function(t) {
2473
        const e = z.getElementFromSelector(this);
2474
        if (["A", "AREA"].includes(this.tagName) && t.preventDefault(), r(this)) return;
2475
        I.one(e, Hi, (() => {
2476
            o(this) && this.focus()
2477
        }));
2478
        const i = z.findOne(Mi);
2479
        i && i !== e && Bi.getInstance(i).hide(), Bi.getOrCreateInstance(e).toggle(this)
2480
    })), I.on(window, "load.bs.offcanvas.data-api", (() => {
2481
        for (const t of z.find(Mi)) Bi.getOrCreateInstance(t).show()
2482
    })), I.on(window, "resize.bs.offcanvas", (() => {
2483
        for (const t of z.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(t).position && Bi.getOrCreateInstance(t).hide()
2484
    })), R(Bi), f(Bi);
2485
    const zi = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
2486
        Ri = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
2487
        qi = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
2488
        Vi = (t, e) => {
2489
            const i = t.nodeName.toLowerCase();
2490
            return e.includes(i) ? !zi.has(i) || Boolean(Ri.test(t.nodeValue) || qi.test(t.nodeValue)) : e.filter((t => t instanceof RegExp)).some((t => t.test(i)))
2491
        },
2492
        Ki = {
2493
            "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
2494
            a: ["target", "href", "title", "rel"],
2495
            area: [],
2496
            b: [],
2497
            br: [],
2498
            col: [],
2499
            code: [],
2500
            div: [],
2501
            em: [],
2502
            hr: [],
2503
            h1: [],
2504
            h2: [],
2505
            h3: [],
2506
            h4: [],
2507
            h5: [],
2508
            h6: [],
2509
            i: [],
2510
            img: ["src", "srcset", "alt", "title", "width", "height"],
2511
            li: [],
2512
            ol: [],
2513
            p: [],
2514
            pre: [],
2515
            s: [],
2516
            small: [],
2517
            span: [],
2518
            sub: [],
2519
            sup: [],
2520
            strong: [],
2521
            u: [],
2522
            ul: []
2523
        },
2524
        Qi = {
2525
            allowList: Ki,
2526
            content: {},
2527
            extraClass: "",
2528
            html: !1,
2529
            sanitize: !0,
2530
            sanitizeFn: null,
2531
            template: "<div></div>"
2532
        },
2533
        Xi = {
2534
            allowList: "object",
2535
            content: "object",
2536
            extraClass: "(string|function)",
2537
            html: "boolean",
2538
            sanitize: "boolean",
2539
            sanitizeFn: "(null|function)",
2540
            template: "string"
2541
        },
2542
        Yi = {
2543
            entry: "(string|element|function|null)",
2544
            selector: "(string|element)"
2545
        };
2546
    class Ui extends $ {
2547
        constructor(t) {
2548
            super(), this._config = this._getConfig(t)
2549
        }
2550
        static get Default() {
2551
            return Qi
2552
        }
2553
        static get DefaultType() {
2554
            return Xi
2555
        }
2556
        static get NAME() {
2557
            return "TemplateFactory"
2558
        }
2559
        getContent() {
2560
            return Object.values(this._config.content).map((t => this._resolvePossibleFunction(t))).filter(Boolean)
2561
        }
2562
        hasContent() {
2563
            return this.getContent().length > 0
2564
        }
2565
        changeContent(t) {
2566
            return this._checkContent(t), this._config.content = {
2567
                ...this._config.content,
2568
                ...t
2569
            }, this
2570
        }
2571
        toHtml() {
2572
            const t = document.createElement("div");
2573
            t.innerHTML = this._maybeSanitize(this._config.template);
2574
            for (const [e, i] of Object.entries(this._config.content)) this._setContent(t, i, e);
2575
            const e = t.children[0],
2576
                i = this._resolvePossibleFunction(this._config.extraClass);
2577
            return i && e.classList.add(...i.split(" ")), e
2578
        }
2579
        _typeCheckConfig(t) {
2580
            super._typeCheckConfig(t), this._checkContent(t.content)
2581
        }
2582
        _checkContent(t) {
2583
            for (const [e, i] of Object.entries(t)) super._typeCheckConfig({
2584
                selector: e,
2585
                entry: i
2586
            }, Yi)
2587
        }
2588
        _setContent(t, e, i) {
2589
            const o = z.findOne(i, t);
2590
            o && ((e = this._resolvePossibleFunction(e)) ? n(e) ? this._putElementInTemplate(s(e), o) : this._config.html ? o.innerHTML = this._maybeSanitize(e) : o.textContent = e : o.remove())
2591
        }
2592
        _maybeSanitize(t) {
2593
            return this._config.sanitize ? function(t, e, i) {
2594
                if (!t.length) return t;
2595
                if (i && "function" == typeof i) return i(t);
2596
                const n = (new window.DOMParser).parseFromString(t, "text/html"),
2597
                    s = [].concat(...n.body.querySelectorAll("*"));
2598
                for (const t of s) {
2599
                    const i = t.nodeName.toLowerCase();
2600
                    if (!Object.keys(e).includes(i)) {
2601
                        t.remove();
2602
                        continue
2603
                    }
2604
                    const n = [].concat(...t.attributes),
2605
                        s = [].concat(e["*"] || [], e[i] || []);
2606
                    for (const e of n) Vi(e, s) || t.removeAttribute(e.nodeName)
2607
                }
2608
                return n.body.innerHTML
2609
            }(t, this._config.allowList, this._config.sanitizeFn) : t
2610
        }
2611
        _resolvePossibleFunction(t) {
2612
            return p(t, [this])
2613
        }
2614
        _putElementInTemplate(t, e) {
2615
            if (this._config.html) return e.innerHTML = "", void e.append(t);
2616
            e.textContent = t.textContent
2617
        }
2618
    }
2619
    const Gi = new Set(["sanitize", "allowList", "sanitizeFn"]),
2620
        Ji = "fade",
2621
        Zi = "show",
2622
        tn = ".modal",
2623
        en = "hide.bs.modal",
2624
        nn = "hover",
2625
        sn = "focus",
2626
        on = {
2627
            AUTO: "auto",
2628
            TOP: "top",
2629
            RIGHT: u() ? "left" : "right",
2630
            BOTTOM: "bottom",
2631
            LEFT: u() ? "right" : "left"
2632
        },
2633
        rn = {
2634
            allowList: Ki,
2635
            animation: !0,
2636
            boundary: "clippingParents",
2637
            container: !1,
2638
            customClass: "",
2639
            delay: 0,
2640
            fallbackPlacements: ["top", "right", "bottom", "left"],
2641
            html: !1,
2642
            offset: [0, 0],
2643
            placement: "top",
2644
            popperConfig: null,
2645
            sanitize: !0,
2646
            sanitizeFn: null,
2647
            selector: !1,
2648
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
2649
            title: "",
2650
            trigger: "hover focus"
2651
        },
2652
        an = {
2653
            allowList: "object",
2654
            animation: "boolean",
2655
            boundary: "(string|element)",
2656
            container: "(string|element|boolean)",
2657
            customClass: "(string|function)",
2658
            delay: "(number|object)",
2659
            fallbackPlacements: "array",
2660
            html: "boolean",
2661
            offset: "(array|string|function)",
2662
            placement: "(string|function)",
2663
            popperConfig: "(null|object|function)",
2664
            sanitize: "boolean",
2665
            sanitizeFn: "(null|function)",
2666
            selector: "(string|boolean)",
2667
            template: "string",
2668
            title: "(string|element|function)",
2669
            trigger: "string"
2670
        };
2671
    class ln extends W {
2672
        constructor(t, e) {
2673
            if (void 0 === Ve) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
2674
            super(t, e), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle()
2675
        }
2676
        static get Default() {
2677
            return rn
2678
        }
2679
        static get DefaultType() {
2680
            return an
2681
        }
2682
        static get NAME() {
2683
            return "tooltip"
2684
        }
2685
        enable() {
2686
            this._isEnabled = !0
2687
        }
2688
        disable() {
2689
            this._isEnabled = !1
2690
        }
2691
        toggleEnabled() {
2692
            this._isEnabled = !this._isEnabled
2693
        }
2694
        toggle() {
2695
            this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter())
2696
        }
2697
        dispose() {
2698
            clearTimeout(this._timeout), I.off(this._element.closest(tn), en, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose()
2699
        }
2700
        show() {
2701
            if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
2702
            if (!this._isWithContent() || !this._isEnabled) return;
2703
            const t = I.trigger(this._element, this.constructor.eventName("show")),
2704
                e = (a(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
2705
            if (t.defaultPrevented || !e) return;
2706
            this._disposePopper();
2707
            const i = this._getTipElement();
2708
            this._element.setAttribute("aria-describedby", i.getAttribute("id"));
2709
            const {
2710
                container: n
2711
            } = this._config;
2712
            if (this._element.ownerDocument.documentElement.contains(this.tip) || (n.append(i), I.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i), i.classList.add(Zi), "ontouchstart" in document.documentElement)
2713
                for (const t of [].concat(...document.body.children)) I.on(t, "mouseover", l);
2714
            this._queueCallback((() => {
2715
                I.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1
2716
            }), this.tip, this._isAnimated())
2717
        }
2718
        hide() {
2719
            if (this._isShown() && !I.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
2720
                if (this._getTipElement().classList.remove(Zi), "ontouchstart" in document.documentElement)
2721
                    for (const t of [].concat(...document.body.children)) I.off(t, "mouseover", l);
2722
                this._activeTrigger.click = !1, this._activeTrigger.focus = !1, this._activeTrigger.hover = !1, this._isHovered = null, this._queueCallback((() => {
2723
                    this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), I.trigger(this._element, this.constructor.eventName("hidden")))
2724
                }), this.tip, this._isAnimated())
2725
            }
2726
        }
2727
        update() {
2728
            this._popper && this._popper.update()
2729
        }
2730
        _isWithContent() {
2731
            return Boolean(this._getTitle())
2732
        }
2733
        _getTipElement() {
2734
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
2735
        }
2736
        _createTipElement(t) {
2737
            const e = this._getTemplateFactory(t).toHtml();
2738
            if (!e) return null;
2739
            e.classList.remove(Ji, Zi), e.classList.add(`bs-${this.constructor.NAME}-auto`);
2740
            const i = (t => {
2741
                do {
2742
                    t += Math.floor(1e6 * Math.random())
2743
                } while (document.getElementById(t));
2744
                return t
2745
            })(this.constructor.NAME).toString();
2746
            return e.setAttribute("id", i), this._isAnimated() && e.classList.add(Ji), e
2747
        }
2748
        setContent(t) {
2749
            this._newContent = t, this._isShown() && (this._disposePopper(), this.show())
2750
        }
2751
        _getTemplateFactory(t) {
2752
            return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Ui({
2753
                ...this._config,
2754
                content: t,
2755
                extraClass: this._resolvePossibleFunction(this._config.customClass)
2756
            }), this._templateFactory
2757
        }
2758
        _getContentForTemplate() {
2759
            return {
2760
                ".tooltip-inner": this._getTitle()
2761
            }
2762
        }
2763
        _getTitle() {
2764
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title")
2765
        }
2766
        _initializeOnDelegatedTarget(t) {
2767
            return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
2768
        }
2769
        _isAnimated() {
2770
            return this._config.animation || this.tip && this.tip.classList.contains(Ji)
2771
        }
2772
        _isShown() {
2773
            return this.tip && this.tip.classList.contains(Zi)
2774
        }
2775
        _createPopper(t) {
2776
            const e = p(this._config.placement, [this, t, this._element]),
2777
                i = on[e.toUpperCase()];
2778
            return qe(this._element, t, this._getPopperConfig(i))
2779
        }
2780
        _getOffset() {
2781
            const {
2782
                offset: t
2783
            } = this._config;
2784
            return "string" == typeof t ? t.split(",").map((t => Number.parseInt(t, 10))) : "function" == typeof t ? e => t(e, this._element) : t
2785
        }
2786
        _resolvePossibleFunction(t) {
2787
            return p(t, [this._element])
2788
        }
2789
        _getPopperConfig(t) {
2790
            const e = {
2791
                placement: t,
2792
                modifiers: [{
2793
                    name: "flip",
2794
                    options: {
2795
                        fallbackPlacements: this._config.fallbackPlacements
2796
                    }
2797
                }, {
2798
                    name: "offset",
2799
                    options: {
2800
                        offset: this._getOffset()
2801
                    }
2802
                }, {
2803
                    name: "preventOverflow",
2804
                    options: {
2805
                        boundary: this._config.boundary
2806
                    }
2807
                }, {
2808
                    name: "arrow",
2809
                    options: {
2810
                        element: `.${this.constructor.NAME}-arrow`
2811
                    }
2812
                }, {
2813
                    name: "preSetPlacement",
2814
                    enabled: !0,
2815
                    phase: "beforeMain",
2816
                    fn: t => {
2817
                        this._getTipElement().setAttribute("data-popper-placement", t.state.placement)
2818
                    }
2819
                }]
2820
            };
2821
            return {
2822
                ...e,
2823
                ...p(this._config.popperConfig, [e])
2824
            }
2825
        }
2826
        _setListeners() {
2827
            const t = this._config.trigger.split(" ");
2828
            for (const e of t)
2829
                if ("click" === e) I.on(this._element, this.constructor.eventName("click"), this._config.selector, (t => {
2830
                    this._initializeOnDelegatedTarget(t).toggle()
2831
                }));
2832
                else if ("manual" !== e) {
2833
                const t = e === nn ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"),
2834
                    i = e === nn ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
2835
                I.on(this._element, t, this._config.selector, (t => {
2836
                    const e = this._initializeOnDelegatedTarget(t);
2837
                    e._activeTrigger["focusin" === t.type ? sn : nn] = !0, e._enter()
2838
                })), I.on(this._element, i, this._config.selector, (t => {
2839
                    const e = this._initializeOnDelegatedTarget(t);
2840
                    e._activeTrigger["focusout" === t.type ? sn : nn] = e._element.contains(t.relatedTarget), e._leave()
2841
                }))
2842
            }
2843
            this._hideModalHandler = () => {
2844
                this._element && this.hide()
2845
            }, I.on(this._element.closest(tn), en, this._hideModalHandler)
2846
        }
2847
        _fixTitle() {
2848
            const t = this._element.getAttribute("title");
2849
            t && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t), this._element.setAttribute("data-bs-original-title", t), this._element.removeAttribute("title"))
2850
        }
2851
        _enter() {
2852
            this._isShown() || this._isHovered ? this._isHovered = !0 : (this._isHovered = !0, this._setTimeout((() => {
2853
                this._isHovered && this.show()
2854
            }), this._config.delay.show))
2855
        }
2856
        _leave() {
2857
            this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout((() => {
2858
                this._isHovered || this.hide()
2859
            }), this._config.delay.hide))
2860
        }
2861
        _setTimeout(t, e) {
2862
            clearTimeout(this._timeout), this._timeout = setTimeout(t, e)
2863
        }
2864
        _isWithActiveTrigger() {
2865
            return Object.values(this._activeTrigger).includes(!0)
2866
        }
2867
        _getConfig(t) {
2868
            const e = H.getDataAttributes(this._element);
2869
            for (const t of Object.keys(e)) Gi.has(t) && delete e[t];
2870
            return t = {
2871
                ...e,
2872
                ..."object" == typeof t && t ? t : {}
2873
            }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
2874
        }
2875
        _configAfterMerge(t) {
2876
            return t.container = !1 === t.container ? document.body : s(t.container), "number" == typeof t.delay && (t.delay = {
2877
                show: t.delay,
2878
                hide: t.delay
2879
            }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), t
2880
        }
2881
        _getDelegateConfig() {
2882
            const t = {};
2883
            for (const [e, i] of Object.entries(this._config)) this.constructor.Default[e] !== i && (t[e] = i);
2884
            return t.selector = !1, t.trigger = "manual", t
2885
        }
2886
        _disposePopper() {
2887
            this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null)
2888
        }
2889
        static jQueryInterface(t) {
2890
            return this.each((function() {
2891
                const e = ln.getOrCreateInstance(this, t);
2892
                if ("string" == typeof t) {
2893
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
2894
                    e[t]()
2895
                }
2896
            }))
2897
        }
2898
    }
2899
    f(ln);
2900
    const cn = {
2901
            ...ln.Default,
2902
            content: "",
2903
            offset: [0, 8],
2904
            placement: "right",
2905
            template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
2906
            trigger: "click"
2907
        },
2908
        hn = {
2909
            ...ln.DefaultType,
2910
            content: "(null|string|element|function)"
2911
        };
2912
    class dn extends ln {
2913
        static get Default() {
2914
            return cn
2915
        }
2916
        static get DefaultType() {
2917
            return hn
2918
        }
2919
        static get NAME() {
2920
            return "popover"
2921
        }
2922
        _isWithContent() {
2923
            return this._getTitle() || this._getContent()
2924
        }
2925
        _getContentForTemplate() {
2926
            return {
2927
                ".popover-header": this._getTitle(),
2928
                ".popover-body": this._getContent()
2929
            }
2930
        }
2931
        _getContent() {
2932
            return this._resolvePossibleFunction(this._config.content)
2933
        }
2934
        static jQueryInterface(t) {
2935
            return this.each((function() {
2936
                const e = dn.getOrCreateInstance(this, t);
2937
                if ("string" == typeof t) {
2938
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
2939
                    e[t]()
2940
                }
2941
            }))
2942
        }
2943
    }
2944
    f(dn);
2945
    const un = "click.bs.scrollspy",
2946
        fn = "active",
2947
        pn = "[href]",
2948
        mn = {
2949
            offset: null,
2950
            rootMargin: "0px 0px -25%",
2951
            smoothScroll: !1,
2952
            target: null,
2953
            threshold: [.1, .5, 1]
2954
        },
2955
        gn = {
2956
            offset: "(number|null)",
2957
            rootMargin: "string",
2958
            smoothScroll: "boolean",
2959
            target: "element",
2960
            threshold: "array"
2961
        };
2962
    class _n extends W {
2963
        constructor(t, e) {
2964
            super(t, e), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
2965
                visibleEntryTop: 0,
2966
                parentScrollTop: 0
2967
            }, this.refresh()
2968
        }
2969
        static get Default() {
2970
            return mn
2971
        }
2972
        static get DefaultType() {
2973
            return gn
2974
        }
2975
        static get NAME() {
2976
            return "scrollspy"
2977
        }
2978
        refresh() {
2979
            this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
2980
            for (const t of this._observableSections.values()) this._observer.observe(t)
2981
        }
2982
        dispose() {
2983
            this._observer.disconnect(), super.dispose()
2984
        }
2985
        _configAfterMerge(t) {
2986
            return t.target = s(t.target) || document.body, t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin, "string" == typeof t.threshold && (t.threshold = t.threshold.split(",").map((t => Number.parseFloat(t)))), t
2987
        }
2988
        _maybeEnableSmoothScroll() {
2989
            this._config.smoothScroll && (I.off(this._config.target, un), I.on(this._config.target, un, pn, (t => {
2990
                const e = this._observableSections.get(t.target.hash);
2991
                if (e) {
2992
                    t.preventDefault();
2993
                    const i = this._rootElement || window,
2994
                        n = e.offsetTop - this._element.offsetTop;
2995
                    if (i.scrollTo) return void i.scrollTo({
2996
                        top: n,
2997
                        behavior: "smooth"
2998
                    });
2999
                    i.scrollTop = n
3000
                }
3001
            })))
3002
        }
3003
        _getNewObserver() {
3004
            const t = {
3005
                root: this._rootElement,
3006
                threshold: this._config.threshold,
3007
                rootMargin: this._config.rootMargin
3008
            };
3009
            return new IntersectionObserver((t => this._observerCallback(t)), t)
3010
        }
3011
        _observerCallback(t) {
3012
            const e = t => this._targetLinks.get(`#${t.target.id}`),
3013
                i = t => {
3014
                    this._previousScrollData.visibleEntryTop = t.target.offsetTop, this._process(e(t))
3015
                },
3016
                n = (this._rootElement || document.documentElement).scrollTop,
3017
                s = n >= this._previousScrollData.parentScrollTop;
3018
            this._previousScrollData.parentScrollTop = n;
3019
            for (const o of t) {
3020
                if (!o.isIntersecting) {
3021
                    this._activeTarget = null, this._clearActiveClass(e(o));
3022
                    continue
3023
                }
3024
                const t = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
3025
                if (s && t) {
3026
                    if (i(o), !n) return
3027
                } else s || t || i(o)
3028
            }
3029
        }
3030
        _initializeTargetsAndObservables() {
3031
            this._targetLinks = new Map, this._observableSections = new Map;
3032
            const t = z.find(pn, this._config.target);
3033
            for (const e of t) {
3034
                if (!e.hash || r(e)) continue;
3035
                const t = z.findOne(e.hash, this._element);
3036
                o(t) && (this._targetLinks.set(e.hash, e), this._observableSections.set(e.hash, t))
3037
            }
3038
        }
3039
        _process(t) {
3040
            this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(fn), this._activateParents(t), I.trigger(this._element, "activate.bs.scrollspy", {
3041
                relatedTarget: t
3042
            }))
3043
        }
3044
        _activateParents(t) {
3045
            if (t.classList.contains("dropdown-item")) z.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(fn);
3046
            else
3047
                for (const e of z.parents(t, ".nav, .list-group"))
3048
                    for (const t of z.prev(e, ".nav-link, .nav-item > .nav-link, .list-group-item")) t.classList.add(fn)
3049
        }
3050
        _clearActiveClass(t) {
3051
            t.classList.remove(fn);
3052
            const e = z.find("[href].active", t);
3053
            for (const t of e) t.classList.remove(fn)
3054
        }
3055
        static jQueryInterface(t) {
3056
            return this.each((function() {
3057
                const e = _n.getOrCreateInstance(this, t);
3058
                if ("string" == typeof t) {
3059
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
3060
                    e[t]()
3061
                }
3062
            }))
3063
        }
3064
    }
3065
    I.on(window, "load.bs.scrollspy.data-api", (() => {
3066
        for (const t of z.find('[data-bs-spy="scroll"]')) _n.getOrCreateInstance(t)
3067
    })), f(_n);
3068
    const bn = "ArrowLeft",
3069
        vn = "ArrowRight",
3070
        yn = "ArrowUp",
3071
        wn = "ArrowDown",
3072
        An = "active",
3073
        En = "fade",
3074
        Tn = "show",
3075
        Cn = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
3076
        On = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${Cn}`;
3077
    class xn extends W {
3078
        constructor(t) {
3079
            super(t), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), I.on(this._element, "keydown.bs.tab", (t => this._keydown(t))))
3080
        }
3081
        static get NAME() {
3082
            return "tab"
3083
        }
3084
        show() {
3085
            const t = this._element;
3086
            if (this._elemIsActive(t)) return;
3087
            const e = this._getActiveElem(),
3088
                i = e ? I.trigger(e, "hide.bs.tab", {
3089
                    relatedTarget: t
3090
                }) : null;
3091
            I.trigger(t, "show.bs.tab", {
3092
                relatedTarget: e
3093
            }).defaultPrevented || i && i.defaultPrevented || (this._deactivate(e, t), this._activate(t, e))
3094
        }
3095
        _activate(t, e) {
3096
            t && (t.classList.add(An), this._activate(z.getElementFromSelector(t)), this._queueCallback((() => {
3097
                "tab" === t.getAttribute("role") ? (t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), I.trigger(t, "shown.bs.tab", {
3098
                    relatedTarget: e
3099
                })) : t.classList.add(Tn)
3100
            }), t, t.classList.contains(En)))
3101
        }
3102
        _deactivate(t, e) {
3103
            t && (t.classList.remove(An), t.blur(), this._deactivate(z.getElementFromSelector(t)), this._queueCallback((() => {
3104
                "tab" === t.getAttribute("role") ? (t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), I.trigger(t, "hidden.bs.tab", {
3105
                    relatedTarget: e
3106
                })) : t.classList.remove(Tn)
3107
            }), t, t.classList.contains(En)))
3108
        }
3109
        _keydown(t) {
3110
            if (![bn, vn, yn, wn].includes(t.key)) return;
3111
            t.stopPropagation(), t.preventDefault();
3112
            const e = [vn, wn].includes(t.key),
3113
                i = g(this._getChildren().filter((t => !r(t))), t.target, e, !0);
3114
            i && (i.focus({
3115
                preventScroll: !0
3116
            }), xn.getOrCreateInstance(i).show())
3117
        }
3118
        _getChildren() {
3119
            return z.find(On, this._parent)
3120
        }
3121
        _getActiveElem() {
3122
            return this._getChildren().find((t => this._elemIsActive(t))) || null
3123
        }
3124
        _setInitialAttributes(t, e) {
3125
            this._setAttributeIfNotExists(t, "role", "tablist");
3126
            for (const t of e) this._setInitialAttributesOnChild(t)
3127
        }
3128
        _setInitialAttributesOnChild(t) {
3129
            t = this._getInnerElement(t);
3130
            const e = this._elemIsActive(t),
3131
                i = this._getOuterElement(t);
3132
            t.setAttribute("aria-selected", e), i !== t && this._setAttributeIfNotExists(i, "role", "presentation"), e || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t)
3133
        }
3134
        _setInitialAttributesOnTargetPanel(t) {
3135
            const e = z.getElementFromSelector(t);
3136
            e && (this._setAttributeIfNotExists(e, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `#${t.id}`))
3137
        }
3138
        _toggleDropDown(t, e) {
3139
            const i = this._getOuterElement(t);
3140
            if (!i.classList.contains("dropdown")) return;
3141
            const n = (t, n) => {
3142
                const s = z.findOne(t, i);
3143
                s && s.classList.toggle(n, e)
3144
            };
3145
            n(".dropdown-toggle", An), n(".dropdown-menu", Tn), i.setAttribute("aria-expanded", e)
3146
        }
3147
        _setAttributeIfNotExists(t, e, i) {
3148
            t.hasAttribute(e) || t.setAttribute(e, i)
3149
        }
3150
        _elemIsActive(t) {
3151
            return t.classList.contains(An)
3152
        }
3153
        _getInnerElement(t) {
3154
            return t.matches(On) ? t : z.findOne(On, t)
3155
        }
3156
        _getOuterElement(t) {
3157
            return t.closest(".nav-item, .list-group-item") || t
3158
        }
3159
        static jQueryInterface(t) {
3160
            return this.each((function() {
3161
                const e = xn.getOrCreateInstance(this);
3162
                if ("string" == typeof t) {
3163
                    if (void 0 === e[t] || t.startsWith("_") || "constructor" === t) throw new TypeError(`No method named "${t}"`);
3164
                    e[t]()
3165
                }
3166
            }))
3167
        }
3168
    }
3169
    I.on(document, "click.bs.tab", Cn, (function(t) {
3170
        ["A", "AREA"].includes(this.tagName) && t.preventDefault(), r(this) || xn.getOrCreateInstance(this).show()
3171
    })), I.on(window, "load.bs.tab", (() => {
3172
        for (const t of z.find('.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]')) xn.getOrCreateInstance(t)
3173
    })), f(xn);
3174
    const kn = "hide",
3175
        Ln = "show",
3176
        Sn = "showing",
3177
        Dn = {
3178
            animation: "boolean",
3179
            autohide: "boolean",
3180
            delay: "number"
3181
        },
3182
        In = {
3183
            animation: !0,
3184
            autohide: !0,
3185
            delay: 5e3
3186
        };
3187
    class Nn extends W {
3188
        constructor(t, e) {
3189
            super(t, e), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
3190
        }
3191
        static get Default() {
3192
            return In
3193
        }
3194
        static get DefaultType() {
3195
            return Dn
3196
        }
3197
        static get NAME() {
3198
            return "toast"
3199
        }
3200
        show() {
3201
            I.trigger(this._element, "show.bs.toast").defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(kn), c(this._element), this._element.classList.add(Ln, Sn), this._queueCallback((() => {
3202
                this._element.classList.remove(Sn), I.trigger(this._element, "shown.bs.toast"), this._maybeScheduleHide()
3203
            }), this._element, this._config.animation))
3204
        }
3205
        hide() {
3206
            this.isShown() && (I.trigger(this._element, "hide.bs.toast").defaultPrevented || (this._element.classList.add(Sn), this._queueCallback((() => {
3207
                this._element.classList.add(kn), this._element.classList.remove(Sn, Ln), I.trigger(this._element, "hidden.bs.toast")
3208
            }), this._element, this._config.animation)))
3209
        }
3210
        dispose() {
3211
            this._clearTimeout(), this.isShown() && this._element.classList.remove(Ln), super.dispose()
3212
        }
3213
        isShown() {
3214
            return this._element.classList.contains(Ln)
3215
        }
3216
        _maybeScheduleHide() {
3217
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout((() => {
3218
                this.hide()
3219
            }), this._config.delay)))
3220
        }
3221
        _onInteraction(t, e) {
3222
            switch (t.type) {
3223
                case "mouseover":
3224
                case "mouseout":
3225
                    this._hasMouseInteraction = e;
3226
                    break;
3227
                case "focusin":
3228
                case "focusout":
3229
                    this._hasKeyboardInteraction = e
3230
            }
3231
            if (e) return void this._clearTimeout();
3232
            const i = t.relatedTarget;
3233
            this._element === i || this._element.contains(i) || this._maybeScheduleHide()
3234
        }
3235
        _setListeners() {
3236
            I.on(this._element, "mouseover.bs.toast", (t => this._onInteraction(t, !0))), I.on(this._element, "mouseout.bs.toast", (t => this._onInteraction(t, !1))), I.on(this._element, "focusin.bs.toast", (t => this._onInteraction(t, !0))), I.on(this._element, "focusout.bs.toast", (t => this._onInteraction(t, !1)))
3237
        }
3238
        _clearTimeout() {
3239
            clearTimeout(this._timeout), this._timeout = null
3240
        }
3241
        static jQueryInterface(t) {
3242
            return this.each((function() {
3243
                const e = Nn.getOrCreateInstance(this, t);
3244
                if ("string" == typeof t) {
3245
                    if (void 0 === e[t]) throw new TypeError(`No method named "${t}"`);
3246
                    e[t](this)
3247
                }
3248
            }))
3249
        }
3250
    }
3251
    return R(Nn), f(Nn), {
3252
        Alert: q,
3253
        Button: K,
3254
        Carousel: rt,
3255
        Collapse: ft,
3256
        Dropdown: ci,
3257
        Modal: Ii,
3258
        Offcanvas: Bi,
3259
        Popover: dn,
3260
        ScrollSpy: _n,
3261
        Tab: xn,
3262
        Toast: Nn,
3263
        Tooltip: ln
3264
    }
3265
}));
3266
//# sourceMappingURL=bootstrap.bundle.min.js.map
